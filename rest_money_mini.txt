------- file: ./SECURITY.md ------- # Security Practices <!-- ## Authentication & Authorization - **JWT with strong algorithms** (RS256, HS512) - **OAuth2** for third-party integrations - **Role-based access control** (RBAC) enforced at API/DB levels --> ## Data Protection - **All inputs sanitized** (Zod for validation, parameterized SQL queries) - **Secrets management**: - Never hardcoded - use environment variables + GitHub Actions secrets - Database credentials rotated quarterly - **Encryption**: - TLS 1.2+ enforced (via `helmet()`) - Sensitive data encrypted at rest (AES-256) ## API Security ```typescript // Example security middleware app.use( helmet({ contentSecurityPolicy: { directives: { defaultSrc: ["'self'"], scriptSrc: ["'self'", 'trusted.cdn.com'] } }, hsts: { maxAge: 31536000, includeSubDomains: true } }) ) ``` ------- file: ./eslint.config.mjs ------- import eslint from '@typescript-eslint/eslint-plugin' import tsParser from '@typescript-eslint/parser' export default [ { files: ['**/*.ts'], ignores: ['**/node_modules/**', '**/dist/**', '**/build/**', '**/coverage/**', '**/logs/**', '**/entity.ts'], // Ignore build and dependency folders plugins: { '@typescript-eslint': eslint }, languageOptions: { parser: tsParser, parserOptions: { ecmaVersion: 'latest', sourceType: 'module' } }, rules: { // General Code Quality Rules 'no-unused-vars': 'warn', // Disable base rule in favor of @typescript-eslint/no-unused-vars '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_', varsIgnorePattern: '^_' }], // Allow unused variables starting with `_` '@typescript-eslint/no-explicit-any': 'warn', // Warn against using `any` type // '@typescript-eslint/explicit-function-return-type': 'warn', // Encourage explicit return types for functions // '@typescript-eslint/no-inferrable-types': 'warn', // Disallow explicit type declarations when they can be inferred // '@typescript-eslint/no-empty-function': 'warn', // Warn against empty functions // Style and Formatting Rules indent: ['error', 2], // Enforce 2-space indentation quotes: ['error', 'single'] // Enforce single quotes // 'object-curly-spacing': ['error', 'always'], // Enforce spaces inside curly braces // 'array-bracket-spacing': ['error', 'never'], // Disallow spaces inside array brackets // 'space-before-function-paren': ['error', 'never'], // No space before function parentheses } } ] ------- file: ./scripts/config.sh ------- ## Tempo startup configuration # echo "-- Execution of the project startup configuration script --" # chmod -R 777 ./src/v1/infrastructure/observability/trace_data_volume && echo "Granted 777 permission on trace_data_volume" # if [[ ! -d "./src/v1/infrastructure/observability/trace_data_volume/wal/blocks" ]]; then # echo "tempo:config : Creation of './src/v1/infrastructure/observability/trace_data_volume/wal/blocks' folder" # mkdir -p "./src/v1/infrastructure/observability/trace_data_volume/wal/blocks" # fi # if [[ ! -d "./src/v1/infrastructure/observability/trace_data_volume/blocks" ]]; then # echo "tempo:config : Creation of './src/v1/infrastructure/observability/trace_data_volume/blocks' folder" # mkdir -p "./src/v1/infrastructure/observability/trace_data_volume/blocks" # fi # chmod 777 ./src/v1/infrastructure/observability/trace_data_volume/wal # chmod 777 ./src/v1/infrastructure/observability/trace_data_volume/blocks ## Observabilty if [[ ! -d "./src/v1/infrastructure/observability/grafana_data_volume" ]]; then echo "tempo:config : Creation of './src/v1/infrastructure/observability/grafana_data_volume' folder" mkdir -p "./src/v1/infrastructure/observability/grafana_data_volume" fi chmod 777 ./src/v1/infrastructure/observability/grafana_data_volume && echo "Granted 777 permission on grafana_data_volume" # End of script echo "-- End of startup configuration script --" ------- file: ./scripts/better-stack.install.sh ------- ## Set up of better-stack (docker images, volumes and network) echo "----------------------" echo $BSKEY echo "----------------------" curl -sSL https://raw.githubusercontent.com/BetterStackHQ/collector/main/install.sh | COLLECTOR_SECRET=KPiZpR18UCFLGupf1UsJDvRjkR4m61uW bash && echo "Better-slack script ended correctly" || echo "fail launching better-slack conf , something went wrong" && exit 1 echo "End of better slack configuration" exit 0 ------- file: ./scripts/minify_p.sh ------- echo "" > project_mini.log find . -type f \ ! -path "*/node_modules/*" \ ! -path "*/logs/*" \ ! -path "*/coverage/*" \ ! -path "*/db_volume/*" \ ! -path "*/grafana_data_volume/*" \ ! -path "*/trace_data_volume/*" \ ! -path "*/.git/*" \ ! -path "*/github/*" \ ! -name "package.json" \ ! -name "package-lock.json" | \ while read -r file; do echo "------- file: $file -------" >> project_mini.log cat "$file" >> project_mini.log echo "" >> project_mini.log done ------- file: ./tests/integration/presentation_routes_user.test.ts ------- import chai from 'chai' import { expect } from 'chai' import { describe, it } from 'mocha' import app from '../../src/app' import { DockerComposeEnvironment, PullPolicy, StartedDockerComposeEnvironment, Wait } from 'testcontainers' import request from 'supertest' import { createSandbox, SinonSandbox } from 'sinon' import logger from '../../src/v1/helpers/logger' import { errorAPIUSER } from '../../src/v1/presentation/routes/user/error.dto' import { moneyTypesO } from '../../src/v1/domain' const DB_READY_WAIT_MS = 30000 describe('Integration tests - presentation:routes:user', () => { const originalEnv = { ...process.env } const sandbox: SinonSandbox = createSandbox() // Dont accidentally fetch the real database (use the containerized test environment) ! process.env.DB_URI = '' process.env.DB_HOST = '' // This variable will store the test environment from the docker-compose let dockerComposeEnvironment: StartedDockerComposeEnvironment // This is a portfolio API, in a real project, use a .env ! const test_env = { DB_DRIVER: 'mysql', DB_USERNAME: 'mysql', DB_PASSWORD: 'mypass', DB_DATABASE_NAME: 'mydb', DB_PORT: '3306', DOCKER_APP_NETWORK: 'my_app_network', API_PORT: '8080', LOGLEVEL: 'debug' } process.env = { ...process.env, ...test_env } // This string will store the test database uri to fetch let dbUriTest: string = '' // This is test user ids use through all tests (as recipient and giver for money transfer tests) let testUserId1: string = '' let testUserId2: string = '' const urlBase: string = 'api/v1' before(async () => { const composeFilePath = '.' const composeFile = 'docker-compose.yaml' try { dockerComposeEnvironment = await new DockerComposeEnvironment(composeFilePath, composeFile) .withPullPolicy(PullPolicy.defaultPolicy()) .withEnvironment(test_env) .withWaitStrategy('db-1', Wait.forLogMessage('ready for connections')) .up(['db']) await new Promise((resolve) => setTimeout(resolve, DB_READY_WAIT_MS)) } catch (error) { const errorInfo = `Docker Compose environment setup failed - ${String(error)}` logger.error(errorInfo) chai.assert.fail(errorInfo) } const dbContainer = dockerComposeEnvironment.getContainer('db-1') const dbPort = Number(process.env.DB_PORT) || 3306 dbUriTest = `${process.env.DB_DRIVER}://${process.env.DB_USERNAME}:${process.env.DB_PASSWORD}@${dbContainer.getHost()}:${dbContainer.getMappedPort(dbPort)}/${process.env.DB_DATABASE_NAME}` process.env.DB_URI = dbUriTest }) after(async () => { await dockerComposeEnvironment.down() process.env = originalEnv sandbox.restore() }) describe('src > v1 > presentation > routes > user > GET (getting all the users)', () => { beforeEach(() => { sandbox.restore() }) it('Should get all users from DB', async () => { const response = await request(app).get(`/${urlBase}/user/`).set('Accept', 'application/json') const body = JSON.parse(response.text) // This user will be used through the whole file testUserId2 = body.data[1].userId expect(response.statusCode).to.be.within(200, 299) expect(body.data).to.be.an('array') expect(body.data).length.above(0) }) }) describe('src > v1 > presentation > routes > user > stream > GET (getting all the users - stream)', () => { beforeEach(() => { sandbox.restore() }) it('Should get all users from DB from a stream', async () => { const resp = await request(app).get(`/${urlBase}/user/stream`) if (resp instanceof Error) chai.assert.fail('Error - Impossible to get the data stream from route') const users = resp.text.split('\n').slice(0, -1) expect(resp.statusCode).to.be.within(200, 299) expect(users).to.be.an('array') for (const chunk of users) { const user = JSON.parse(chunk) expect(user).to.have.property('userId') expect(user).to.have.property('firstname') expect(user).to.have.property('Wallet') } }) }) describe('src > v1 > presentation > routes > user > POST (adding a new user)', () => { beforeEach(() => { sandbox.restore() }) it('should add a new user', async () => { const newUser = { firstname: 'test_Rosita', lastname: 'test_Espinosa' } const response = await request(app).post(`/${urlBase}/user/`).send(newUser).set('Accept', 'application/json') const body = JSON.parse(response.text) // Get the user id from DB response in addUser testUserId1 = body.data.customer_id // logger.debug(JSON.stringify(body)) expect(response.statusCode).to.be.within(200, 299) expect(body.data).to.not.be.empty expect(body.data.firstname).to.be.not.empty expect(body.data.firstname).to.equal(newUser.firstname) expect(body.data.lastname).to.equal(newUser.lastname) }) }) describe('src > v1 > presentation > routes > user > GET (single user)', () => { beforeEach(() => { sandbox.restore() }) it('should return a single user', async () => { const response = await request(app).get(`/${urlBase}/user/${testUserId1}`).set('Accept', 'application/json') const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(200, 299) expect(body.data).to.have.property('userId') }) it('should fail returning a single user ( wrong parameter in route )', async () => { const wrongUserId = 123 const response = await request(app).get(`/${urlBase}/user/${wrongUserId}`).set('Accept', 'application/json') const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(400, 499) expect(body).to.have.property('middlewareError') }) it('should fail returning a single user ( user dont exists )', async () => { const mockErrorLogger = sandbox.stub(logger, 'error') const wrongUserId = 'zz2c990b6-029c-11ed-b939-0242ac12002' const response = await request(app).get(`/${urlBase}/user/${wrongUserId}`).set('Accept', 'application/json') expect(response.statusCode).to.be.within(500, 599) expect(response.text).includes('Impossible to get any') sandbox.assert.called(mockErrorLogger) }) }) describe('src > v1 > presentation > routes > user > POST (transfer)', () => { beforeEach(() => { sandbox.restore() }) it('should successfully transfer money between users', async () => { const validTransferData = { senderId: testUserId2, receiverId: testUserId1, amount: 7, currency: moneyTypesO.hard_currency } const response = await request(app).post(`/${urlBase}/user/transfer`).send(validTransferData).set('Accept', 'application/json') const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(200, 299) expect(body).to.have.property('data') }) it('should fail transferring money (missing required fields)', async () => { const invalidData = { senderId: testUserId1 // missing other required fields } const response = await request(app).post(`/${urlBase}/user/transfer`).send(invalidData).set('Accept', 'application/json').expect('Content-Type', /json/) const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(400, 499) expect(body).to.deep.equal(errorAPIUSER.errorAPIUserTransfertWrongParams) }) it('should fail transferring money (illegal amount)', async () => { const validTransferData = { senderId: testUserId2, receiverId: testUserId1, amount: 101, currency: moneyTypesO.hard_currency } const invalidData = { ...validTransferData, amount: -100 } const response = await request(app).post(`/${urlBase}/user/transfer`).send(invalidData).set('Accept', 'application/json').expect('Content-Type', /json/) const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(400, 499) expect(body).to.deep.equal(errorAPIUSER.errorAPIUserTransferIllegalAmount) }) it('Should fail transferring money (senderId === receiverId)', async () => { const invalidTransferData = { senderId: testUserId1, receiverId: testUserId1, amount: 10, currency: moneyTypesO.hard_currency } const response = await request(app).post(`/${urlBase}/user/transfer`).send(invalidTransferData).set('Accept', 'application/json') const body = JSON.parse(response.text) expect(response.statusCode).to.be.within(400, 499) expect(body).to.deep.equal(errorAPIUSER.errorAPIUserTransferSelf!) }) }) describe('src > v1 > presentation > routes > user > DELETE', () => { beforeEach(() => { sandbox.restore() }) it('should delete a specified user', async () => { const response = await request(app).delete(`/${urlBase}/user/${testUserId1}`).set('Accept', 'application/json') expect(response.statusCode).to.be.within(200, 299) expect(response.text).to.not.be.null expect(response.ok).to.be.equal(true) }) }) }) ------- file: ./tests/unit/v1/infrastructure_database_db_connection.test.ts ------- import { DataSource } from 'typeorm' import * as sinon from 'sinon' import { expect } from 'chai' import { describe, it } from 'mocha' import { connectionDB } from '../../../src/v1/infrastructure/persistence/database/db_connection/connectionFile' import * as modConnectionFile from '../../../src/v1/infrastructure/persistence/database/db_connection/connectionFile' import logger from '../../../src/v1/helpers/logger' describe('Unit tests - infrastructure:database:db_connection', () => { const sandbox = sinon.createSandbox() // Dont accidentally fetch real database (use of mocks in the tests) ! process.env.DB_URI = '' process.env.DB_HOST = '' after(() => { sandbox.restore() }) describe('src > v1 > infrastructure > database > db_connection > connectionFile > connectionDB', () => { beforeEach(() => { sandbox.restore() }) it('Should successfully connect to DB on first attempt', async () => { const mockConnection = { someConnection: true } as unknown as DataSource const mockTryToConnectDB = sandbox.stub().resolves(mockConnection) const mockWarnLogger = sandbox.stub(logger, 'warn') sandbox.replace(modConnectionFile, 'tryToConnectDB', mockTryToConnectDB) const result = await connectionDB() sandbox.assert.calledOnce(mockTryToConnectDB) sandbox.assert.notCalled(mockWarnLogger) expect(result).to.equal(mockConnection) }) it('Should successfully connect to DB after one retry', async () => { const mockConnection = { someConnection: 'Ok' } as unknown as DataSource const mockTryToConnectDB = sandbox.stub() const mockWarnLogger = sandbox.stub(logger, 'warn') mockTryToConnectDB.onFirstCall().rejects(new Error('First attempt failed')) mockTryToConnectDB.onSecondCall().resolves(mockConnection) sandbox.replace(modConnectionFile, 'tryToConnectDB', mockTryToConnectDB) const connectionPromise = connectionDB() const result = await connectionPromise sandbox.assert.calledTwice(mockTryToConnectDB) sandbox.assert.calledOnce(mockWarnLogger) expect(result).to.equal(mockConnection) }) it('Should Successfully connect to DB on last attempt', async () => { const mockConnection = { someConnection: 'Ok3' } as unknown as DataSource const mockTryToConnectDB = sandbox.stub() const mockWarnLogger = sandbox.stub(logger, 'warn') // Setup mock behavior - fail 3 times, succeed on 4th mockTryToConnectDB.onFirstCall().rejects(new Error('First attempt failed')) mockTryToConnectDB.onSecondCall().rejects(new Error('Second attempt failed')) mockTryToConnectDB.onThirdCall().rejects(new Error('Third attempt failed')) mockTryToConnectDB.onCall(3).resolves(mockConnection) sandbox.replace(modConnectionFile, 'tryToConnectDB', mockTryToConnectDB) const connectionPromise = connectionDB() const result = await connectionPromise sandbox.assert.callCount(mockTryToConnectDB, 4) sandbox.assert.calledThrice(mockWarnLogger) expect(result).to.equal(mockConnection) }) it('Should Fail after maximum connection attempts', async () => { const testError = new Error('Connection failed') const mockTryToConnectDB = sandbox.stub().rejects(testError) const mockWarnLogger = sandbox.stub(logger, 'warn') const mockErrorLogger = sandbox.stub(logger, 'error') sandbox.replace(modConnectionFile, 'tryToConnectDB', mockTryToConnectDB) const connectionPromise = connectionDB() try { await connectionPromise expect.fail('Should have thrown an error') } catch (err) { if (!(err instanceof Error)) { expect.fail('Should be an Error instance') } expect(err.message).to.include('Error - Impossible to connect to db after 4 attempts') expect(err.message).to.include('Connection failed') sandbox.assert.callCount(mockTryToConnectDB, 4) // Initial + 3 retries sandbox.assert.calledThrice(mockWarnLogger) sandbox.assert.called(mockErrorLogger) } }) it('Should successfully respects custom retry parameters', async () => { const testError = new Error('Connection failed') const mockTryToConnectDB = sandbox.stub().rejects(testError) const mockWarnLogger = sandbox.stub(logger, 'warn') const mockErrorLogger = sandbox.stub(logger, 'error') sandbox.replace(modConnectionFile, 'tryToConnectDB', mockTryToConnectDB) // Execute test with custom parameters (2 attempts, 500ms base delay) const connectionPromise = connectionDB(1, 2, 500) try { await connectionPromise expect.fail('Should have thrown an error') } catch (err) { if (!(err instanceof Error)) { expect.fail('Should be an Error instance') } expect(err.message).to.include('Error - Impossible to connect to db after 2 attempts') sandbox.assert.callCount(mockTryToConnectDB, 2) // Initial + 1 retry sandbox.assert.calledOnce(mockWarnLogger) sandbox.assert.calledOnce(mockErrorLogger) } }) }) }) ------- file: ./tests/unit/v1/infrastructure_database_customer.test.ts ------- import * as modConnection from '../../../src/v1/infrastructure/persistence/database/db_connection/connectionFile' import { createSandbox, SinonSandbox } from 'sinon' import { describe, it } from 'mocha' import chai from 'chai' import { getAllCustomersDB, customerStreamAdaptor } from '../../../src/v1/infrastructure/persistence/database/customer' import { Readable } from 'stream' import logger from '../../../src/v1/helpers/logger' import { ReadStream } from 'fs' import { DataSource } from 'typeorm' describe('Unit tests - infrastructure:database:customer', () => { const originalEnv = { ...process.env } after(() => { sandbox.restore() process.env = originalEnv }) const sandbox: SinonSandbox = createSandbox() // Dont accidentally fetch real database (use of mocks in the tests) ! process.env.DB_URI = '' process.env.DB_HOST = '' describe('src > v1 > infrastructure > database > customer > index > getAllUserDB ', () => { beforeEach(() => { sandbox.restore() }) it('should successfully retrieve all customers with their wallets', async () => { // Prepare mock data const mockUsers = [ { customer_id: 'customer1', firstname: 'John', lastname: 'Doe', Wallet: { wallet_id: 'wallet1', hard_currency: 1000, soft_currency: 500 } } ] // Create mock connection and repository const mockQueryBuilder = { innerJoinAndMapOne: sandbox.stub().returnsThis(), getMany: sandbox.stub().resolves(mockUsers) } const mockRepository = { createQueryBuilder: sandbox.stub().returns(mockQueryBuilder) } const mockConnection = { getRepository: sandbox.stub().returns(mockRepository) } // Stub getConnection to return mock connection const getConnectionStub = sandbox.stub(modConnection, 'getConnection').resolves(mockConnection as never) try { const result = await getAllCustomersDB() // Assertions chai.assert.exists(result, 'Result should exist') chai.assert.isArray(result, 'Result should be an array') chai.assert.lengthOf(result, mockUsers.length, 'Result should have the same amount of customers that the mock data') // Verify stub calls sandbox.assert.calledOnce(getConnectionStub) sandbox.assert.calledOnce(mockQueryBuilder.innerJoinAndMapOne) sandbox.assert.calledOnce(mockQueryBuilder.getMany) } catch (err) { chai.assert.fail(`Unexpected error: ${err}`) } }) it('should throw an error when database query fails', async () => { // Create an error to simulate database failure const mockError = new Error('Database connection error') // Stub getConnection to return a repository with a failing query const mockQueryBuilder = { innerJoinAndMapOne: sandbox.stub().returnsThis(), getMany: sandbox.stub().rejects(mockError) } const mockRepository = { createQueryBuilder: sandbox.stub().returns(mockQueryBuilder) } const mockConnection = { getRepository: sandbox.stub().returns(mockRepository) } const getConnectionStub = sandbox.stub(modConnection, 'getConnection').resolves(mockConnection as unknown as DataSource) const loggerErrorStub = sandbox.stub(logger, 'error') try { await getAllCustomersDB() chai.assert.fail('Expected an error to be thrown') } catch (err) { chai.assert.exists(err, 'Error should be thrown') chai.assert.instanceOf(err, Error, 'Error should be an Error instance') chai.assert.include((err as Error).message, 'Impossible to retrieve any') // Verify logger was called with the error sandbox.assert.calledOnce(loggerErrorStub) sandbox.assert.calledOnce(getConnectionStub) sandbox.assert.called(loggerErrorStub) } }) }) describe('src > v1 > infrastructure > database > customer > index > customerStreamAdaptor', () => { beforeEach(() => { sandbox.restore() }) it('should adapt stream data correctly', async () => { // Mock customer DB data from a stream const mockChunks = [ { customer_customer_id: 'customer1_id', customer_firstname: 'John', customer_lastname: 'Doe', wallet_customer_id: 'customer1_id', wallet_wallet_id: 'wallet1', wallet_hard_currency: 1000, wallet_soft_currency: 500 } ] // Create a readable stream from mock chunks const mockStream = Readable.from(mockChunks) as ReadStream // Type assertion: mockStream mimics ReadStream behavior const adaptor = customerStreamAdaptor(mockStream) // Results from the async generator to test const results: string[] = [] for await (const item of adaptor) { results.push(item) } // Assertions chai.assert.lengthOf(results, 1, 'Should process one chunk') chai.assert.deepEqual( results[0], JSON.stringify({ userId: 'customer1_id', firstname: 'John', lastname: 'Doe', Wallet: { walletId: 'wallet1', hardCurrency: 1000, softCurrency: 500 } }) + '\n', 'Should correctly adapt and stringify the stream data with a newline' ) }) it('should handle stream errors', async () => { // Create a stream that will throw an error const mockStream = new Readable({ objectMode: true, read() { this.destroy(new Error('Stream read error')) } }) const loggerErrorStub = sandbox.stub(logger, 'error') try { const adaptor = customerStreamAdaptor(mockStream as never) await adaptor.next() chai.assert.fail('Expected an error to be thrown') } catch (err) { chai.assert.exists(err, 'Error should be thrown') if (!(err instanceof Error)) chai.assert.fail('Error should be an Error instance') chai.assert.include(err.message, 'Stream Adaptor error') // Verify logger was called with the error sandbox.assert.calledOnce(loggerErrorStub) } }) }) }) ------- file: ./tests/unit/v1/services_user.test.ts ------- import * as modUserDB from '../../../src/v1/infrastructure/persistence/database/customer' import * as modWalletDB from '../../../src/v1/infrastructure/persistence/database/wallet' import * as modUser from '../../../src/v1/services/user/index' import * as modConnection from '../../../src/v1/infrastructure/persistence/database/db_connection/connectionFile' import { moneyTypes, moneyTypesO } from '../../../src/v1/domain' import { createSandbox, SinonSandbox } from 'sinon' import { describe, it } from 'mocha' import chai from 'chai' import { addCurrency, deleteUserById, saveNewUser, transferMoney, transferMoneyParamsValidator, transferMoneyWithRetry } from '../../../src/v1/services/user/index' import { moneyTransferParamsValidatorErrors, transferMoneyErrors, userFunctionsErrors, transferMoneyWithRetryErrors } from '../../../src/v1/services/user/error.dto' import { transactionQueryRunnerType } from '../../../src/v1/infrastructure/persistence/database/db_connection/connectionFile' import logger from '../../../src/v1/helpers/logger' import { errorType } from '../../../src/v1/domain/error' import { userWalletDTO } from '../../../src/v1/services/user/dto' describe('Unit tests - services:user', () => { const originalEnv = { ...process.env } after(() => { sandbox.restore() process.env = originalEnv }) const sandbox: SinonSandbox = createSandbox() // Dont accidentally fetch real database (use of mocks in the tests) ! process.env.DB_URI = '' process.env.DB_HOST = '' describe('src > v1 > services > user > index > saveNewUser', () => { beforeEach(() => { sandbox.restore() }) it('should create a new user', async () => { const fakeUserDB = { customer_id: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', wallet: { wallet_id: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hard_currency: 2000, soft_currency: 2000 } } const mockSaveNewUserDB = sandbox.stub(modUserDB, 'saveNewCustomerDB').returns(Promise.resolve(fakeUserDB)) try { const response = await saveNewUser(fakeUserDB.firstname, fakeUserDB.lastname) chai.assert.exists(response, 'Should get the correct response') chai.assert.isTrue(mockSaveNewUserDB.calledOnce) } catch (err) { chai.assert.fail(`Should not happen - no error in catch expected - ${err}`) } }) it('should fail creating a new user', async () => { const fakeUser = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockSaveNewUserDB = sandbox.stub(modUserDB, 'saveNewCustomerDB').rejects(null) const mockErrorLogger = sandbox.stub(logger, 'error') try { await saveNewUser(fakeUser.firstname, fakeUser.lastname) chai.assert.fail('Unexpected success') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } else { chai.assert.include(err.message, userFunctionsErrors.ErrorCreatingUser!.message) sandbox.assert.calledOnce(mockSaveNewUserDB) sandbox.assert.calledOnce(mockErrorLogger) } } }) }) describe('src > v1 > services > user > index > addCurrency', () => { beforeEach(() => { sandbox.restore() }) it('should succeed adding currency', async () => { const fakeUser = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockGetUserWalletInfo = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB').resolves(fakeUser) const mockUpdateWalletByWalletIdDB = sandbox.stub(modWalletDB, 'updateWalletByWalletIdDB').resolves(true) const amountToAdd = 150 try { const res = await addCurrency('22ef5564-0234-11ed-b939-0242ac120002', moneyTypesO.soft_currency, amountToAdd) chai.assert.isTrue(res) sandbox.assert.calledOnce(mockGetUserWalletInfo) sandbox.assert.calledOnce(mockUpdateWalletByWalletIdDB) } catch (err) { chai.assert.fail(`Should not get an error - ${String(err)}`) } }) it('should fail (negative amount)', async () => { const amountToAdd = -55 try { await addCurrency('22ef5564-0234-11ed-b939-0242ac120002', moneyTypesO.soft_currency, amountToAdd) chai.assert.fail('Unexpected success') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorInvalidAmount!.message) } }) it('should fail (wrong currency type)', async () => { const amountToAdd = 150 try { await addCurrency('22ef5564-0234-11ed-b939-0242ac120002', 'fake_currency_type' as moneyTypes, amountToAdd) chai.assert.fail('Unexpected success - Should never happen') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorCurrencyType!.message) } }) }) describe('src > v1 > services > user > index > deleteUserById', () => { beforeEach(() => { sandbox.restore() }) it('should delete a single user from DB by its id', async () => { const userToFetch: string = '22ef5564-0234-11ed-b939-0242ac120002' const mockDeleteUserByIdDB = sandbox.stub(modUserDB, 'deleteCustomerByIdDB').returns(Promise.resolve(true)) // const mockDeleteWalletByIdDB = sandbox.stub(modWalletDB, "").returns(Promise.resolve(true)) try { const response = await deleteUserById(userToFetch) chai.assert.exists(response, 'Should get a valid response from DB') chai.assert.isTrue(response, 'Should get true response from DB') chai.assert.isTrue(mockDeleteUserByIdDB.calledOnce) } catch (err) { chai.assert.fail(`Fail - Unable to delete the user - ${err}`) } }) }) describe('src > v1 > services > user > index > transferMoneyParamsValidator', () => { beforeEach(() => { sandbox.restore() }) it('Should return the 2 users info objects correctly', async () => { const validCurrency = moneyTypesO.soft_currency const fakeUserGiver = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 // Sufficient funds } } const fakeUserRecipient = { userId: 'fake_09lo1234-0234-45rt-n632-0242ac129997', firstname: 'fake_Michael', lastname: 'fake_Mercer', Wallet: { walletId: 'fake_888f73b6-027d-11ed-b939-0242ac120987', hardCurrency: 2400, softCurrency: 6700 } } const mockFetchUserDB = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB') mockFetchUserDB.onFirstCall().resolves(fakeUserGiver) mockFetchUserDB.onSecondCall().resolves(fakeUserRecipient) const amount = 100 const [giverUserInfo, recipientUserInfo] = await transferMoneyParamsValidator(validCurrency, fakeUserGiver.userId, fakeUserRecipient.userId, amount) chai.assert.isObject(giverUserInfo) chai.assert.isObject(recipientUserInfo) }) it('Should throw an error for invalid currency type', async () => { const fakeUserGiver = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const fakeUserRecipient = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockFetchUserDB = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB') mockFetchUserDB.onFirstCall().resolves(fakeUserGiver) mockFetchUserDB.onSecondCall().resolves(fakeUserRecipient) const invalidCurrency = 'invalid_currency' const amount = 100 try { await transferMoneyParamsValidator(invalidCurrency as moneyTypes, fakeUserGiver.userId, fakeUserRecipient.userId, amount) chai.assert.fail('Expected error for invalid currency') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorCurrencyType!.message) sandbox.assert.notCalled(mockFetchUserDB) } }) it('Should throw an error for insufficient funds', async () => { const validCurrency = moneyTypesO.soft_currency const fakeUserGiver = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 100 // Insufficient funds } } const fakeUserRecipient = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockFetchUserDB = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB') mockFetchUserDB.onFirstCall().resolves(fakeUserGiver) mockFetchUserDB.onSecondCall().resolves(fakeUserRecipient) const amount = 200 // Attempt to transfer more than available try { await transferMoneyParamsValidator(validCurrency, fakeUserGiver.userId, fakeUserRecipient.userId, amount) chai.assert.fail('Expected error for insufficient funds') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorInsufficientFunds!.message) sandbox.assert.calledOnce(mockFetchUserDB) } }) it('Should throw an error if retrieving giver user info fails', async () => { const mockErrorLogger = sandbox.stub(logger, 'error') const validCurrency = moneyTypesO.soft_currency const fakeUserRecipient = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockFetchUserDB = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB') mockFetchUserDB.onFirstCall().rejects(new Error('test - 1')) mockFetchUserDB.onSecondCall().rejects(null) const amount = 100 try { await transferMoneyParamsValidator(validCurrency, 'fake_giver_id', fakeUserRecipient.userId, amount) // Use a fake giver ID chai.assert.fail('Expected error retrieving giver user info') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorUserInfo!.message) // Verify specific error message sandbox.assert.calledOnce(mockFetchUserDB) sandbox.assert.called(mockErrorLogger) } }) it('Should throw an error if retrieving receiver user info fails', async () => { const mockErrorLogger = sandbox.stub(logger, 'error') const validCurrency = moneyTypesO.soft_currency const fakeUserRecipient = { userId: 'fake_22ef5564-0234-11ed-b939-0242ac120002', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const fakeUserGiver = { // Define fake giver object but don't use it userId: 'fake_giver_id', firstname: 'fake_Eugene', lastname: 'fake_Porter', Wallet: { walletId: 'fake_515f73c2-027d-11ed-b939-0242ac120002', hardCurrency: 2000, softCurrency: 2000 } } const mockFetchUserDB = sandbox.stub(modUserDB, 'getCustomerWalletInfoDB') mockFetchUserDB.onFirstCall().resolves(fakeUserGiver) mockFetchUserDB.onSecondCall().rejects(null) const amount = 100 try { await transferMoneyParamsValidator(validCurrency, 'fake_giver_id', fakeUserRecipient.userId, amount) // Use a fake giver ID chai.assert.fail('Expected error retrieving giver user info') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, moneyTransferParamsValidatorErrors.ErrorUserInfo!.message) // Verify specific error message sandbox.assert.calledTwice(mockFetchUserDB) sandbox.assert.called(mockErrorLogger) } }) }) describe('src > v1 > services > user > index > transferMoney', () => { beforeEach(() => { sandbox.restore() }) it('Successful transfer', async () => { // Mock all the dependent functions const mockTransferMoneyParamsValidator = sandbox .stub(modUser, 'transferMoneyParamsValidator') .resolves([{ Wallet: { walletId: '1234', softCurrency: 123 } }, { Wallet: { walletId: '4321', softCurrency: 300 } }] as unknown as userWalletDTO[]) const mockCreateAndStartTransaction = sandbox .stub(modConnection, 'createAndStartTransaction') .resolves({ someTransactionObject: true } as unknown as transactionQueryRunnerType) const mockAcquireLockOnWallet = sandbox.stub(modConnection, 'acquireLockOnWallet').resolves(true) const mockUpdateWalletByWalletIdTransaction = sandbox.stub(modWalletDB, 'updateWalletByWalletIdTransaction').resolves(true) // Assuming update functions return success indicator (modify as needed) const mockRollBackAndQuitTransactionRunner = sandbox.stub(modConnection, 'rollBackAndQuitTransactionRunner') const mockCommitAndQuitTransactionRunner = sandbox.stub(modConnection, 'commitAndQuitTransactionRunner') const mockErrorLogger = sandbox.stub(logger, 'error') // Call the transferMoneyWithRetry function const result = await transferMoney(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) // Verify all the mocked functions were called as expected sandbox.assert.calledOnce(mockTransferMoneyParamsValidator) sandbox.assert.calledWithExactly(mockTransferMoneyParamsValidator, moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) sandbox.assert.calledOnce(mockCreateAndStartTransaction) sandbox.assert.calledTwice(mockAcquireLockOnWallet) sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '1234') // Replace with actual wallet ID logic sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '4321') // Replace with actual wallet ID logic sandbox.assert.calledTwice(mockUpdateWalletByWalletIdTransaction) // Replace these assertions with the expected arguments and return values based on your implementation sandbox.assert.calledWith( mockUpdateWalletByWalletIdTransaction, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '1234', moneyTypesO.soft_currency, 23 ) sandbox.assert.calledWith( mockUpdateWalletByWalletIdTransaction, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '4321', moneyTypesO.soft_currency, 400 ) sandbox.assert.notCalled(mockRollBackAndQuitTransactionRunner) // No rollback expected in successful case sandbox.assert.calledOnce(mockCommitAndQuitTransactionRunner) sandbox.assert.notCalled(mockErrorLogger) // Expect the result to be true (successful transfer) chai.assert.isTrue(result) }) it('Transfer failure due to transferMoneyParamsValidator error', async () => { const mockTransferMoneyParamsValidator = sandbox.stub(modUser, 'transferMoneyParamsValidator').rejects(new Error('Validation Error')) const mockCreateAndStartTransaction = sandbox .stub(modConnection, 'createAndStartTransaction') .resolves({ someTransactionObject: true } as unknown as transactionQueryRunnerType) const mockErrorLogger = sandbox.stub(logger, 'error') try { await transferMoney(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) // Should not reach here if transferMoneyParamsValidator throws chai.assert.fail('Unexpected successful transfer') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, transferMoneyErrors.ErrorParamsValidator!.message) sandbox.assert.calledOnce(mockTransferMoneyParamsValidator) sandbox.assert.notCalled(mockCreateAndStartTransaction) sandbox.assert.called(mockErrorLogger) } }) it('Transfer failure due to createAndStartTransaction error', async () => { const mockTransferMoneyParamsValidator = sandbox.stub(modUser, 'transferMoneyParamsValidator').resolves([{}, {}] as unknown as userWalletDTO[]) const mockCreateAndStartTransaction = sandbox.stub(modConnection, 'createAndStartTransaction').rejects(new Error('Transaction Error')) const mockAcquireLockOnWallet = sandbox.stub(modConnection, 'acquireLockOnWallet') const mockErrorLogger = sandbox.stub(logger, 'error') try { await transferMoney(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) chai.assert.fail('Unexpected successful transfer') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, transferMoneyErrors.ErrorTransactionCreation!.message) sandbox.assert.calledOnce(mockTransferMoneyParamsValidator) sandbox.assert.calledOnce(mockCreateAndStartTransaction) sandbox.assert.called(mockErrorLogger) sandbox.assert.notCalled(mockAcquireLockOnWallet) } }) it('Transfer failure due to acquireLockOnWallet failure (giver)', async () => { const mockTransferMoneyParamsValidator = sandbox .stub(modUser, 'transferMoneyParamsValidator') .resolves([{ Wallet: { walletId: '1234', softCurrency: 123 } }, { Wallet: { walletId: '4321', softCurrency: 300 } }] as unknown as userWalletDTO[]) const mockCreateAndStartTransaction = sandbox .stub(modConnection, 'createAndStartTransaction') .resolves({ someTransactionObject: true } as unknown as transactionQueryRunnerType) const mockAcquireLockOnWallet = sandbox.stub(modConnection, 'acquireLockOnWallet') mockAcquireLockOnWallet.onFirstCall().rejects(new Error('lock test Error')) mockAcquireLockOnWallet.onSecondCall().resolves(true) const mockUpdateWalletByWalletIdTransaction = sandbox.stub(modWalletDB, 'updateWalletByWalletIdTransaction').resolves(true) // Assuming update functions return success indicator (modify as needed) const mockErrorLogger = sandbox.stub(logger, 'error') try { await transferMoney(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) // Should not reach here if acquireLockOnWallet fails chai.assert.fail('Unexpected successful transfer') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, transferMoneyErrors.ErrorLockAcquisition!.message) sandbox.assert.calledOnce(mockTransferMoneyParamsValidator) sandbox.assert.calledOnce(mockCreateAndStartTransaction) sandbox.assert.called(mockErrorLogger) sandbox.assert.calledTwice(mockAcquireLockOnWallet) sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '1234') // Replace with actual logic sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '4321') // Replace with actual logic sandbox.assert.notCalled(mockUpdateWalletByWalletIdTransaction) // Not called due to earlier error } }) it('Transfer failure due to acquireLockOnWallet failure (recipient)', async () => { const mockTransferMoneyParamsValidator = sandbox .stub(modUser, 'transferMoneyParamsValidator') .resolves([{ Wallet: { walletId: '1234', softCurrency: 123 } }, { Wallet: { walletId: '4321', softCurrency: 300 } }] as unknown as userWalletDTO[]) const mockCreateAndStartTransaction = sandbox .stub(modConnection, 'createAndStartTransaction') .resolves({ someTransactionObject: true } as unknown as transactionQueryRunnerType) const mockAcquireLockOnWallet = sandbox.stub(modConnection, 'acquireLockOnWallet') mockAcquireLockOnWallet.onFirstCall().resolves(true) mockAcquireLockOnWallet.onSecondCall().rejects(new Error('lock test Error')) const mockUpdateWalletByWalletIdTransaction = sandbox.stub(modWalletDB, 'updateWalletByWalletIdTransaction').resolves(true) // Assuming update functions return success indicator (modify as needed) const mockErrorLogger = sandbox.stub(logger, 'error') try { await transferMoney(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) // Should not reach here if update fails chai.assert.fail('Unexpected successful transfer') } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, transferMoneyErrors.ErrorLockAcquisition!.message) sandbox.assert.calledOnce(mockTransferMoneyParamsValidator) sandbox.assert.calledOnce(mockCreateAndStartTransaction) sandbox.assert.called(mockErrorLogger) sandbox.assert.calledTwice(mockAcquireLockOnWallet) sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '1234') sandbox.assert.calledWith(mockAcquireLockOnWallet, { someTransactionObject: true } as unknown as transactionQueryRunnerType, '4321') sandbox.assert.notCalled(mockUpdateWalletByWalletIdTransaction) } }) }) describe('src > v1 > services > user > index > transferMoneyWithRetry', () => { beforeEach(() => { sandbox.restore() }) it('Successful transfer (no retry)', async () => { // Mock the transferMoney function to always succeed const mockTransferMoney = sandbox.stub(modUser, 'transferMoney').resolves(true) // Call the transferMoneyWithRetry function const result = await transferMoneyWithRetry(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100, 300) // Verify the transferMoney function was called once sandbox.assert.calledOnce(mockTransferMoney) sandbox.assert.calledWithExactly(mockTransferMoney, moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) // Expect the result to be true (successful transfer) chai.assert.isTrue(result) }) it('Successful transfer (with 1 retry)', async () => { // Mock the transferMoney function to fail twice and succeed on the third try const mockTransferMoney = sandbox.stub(modUser, 'transferMoney') mockTransferMoney.onFirstCall().rejects(new Error('Error - Lock - Network error')) mockTransferMoney.onSecondCall().resolves(true) const mockWarnLogger = sandbox.stub(logger, 'warn') // Call the transferMoneyWithRetry function const result = await transferMoneyWithRetry(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100, 300) // Verify the transferMoney function was called three times sandbox.assert.calledTwice(mockTransferMoney) sandbox.assert.calledWithExactly(mockTransferMoney, moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) sandbox.assert.calledOnce(mockWarnLogger) // Expect the result to be true (successful transfer after retry) chai.assert.isTrue(result) }) it('Failure - Transfer fail (non-retryable error)', async () => { const mockErrorLogger = sandbox.stub(logger, 'error') const fakeInsufficientFundsError: errorType = { name: 'fakeNetworkError', message: 'Not enough funds to do the transaction' } const mockTransferMoney = sandbox.stub(modUser, 'transferMoney').throws(new Error(fakeInsufficientFundsError.message)) // Call the transferMoneyWithRetry function try { await transferMoneyWithRetry(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100, 300) } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert(err.message.includes('Not enough funds to do the transaction')) sandbox.assert.calledOnce(mockTransferMoney) chai.assert(mockTransferMoney.calledWithExactly(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100)) sandbox.assert.called(mockErrorLogger) } }) it('Failure - Transfer fail (with retryable error followed by non-retryable error)', async () => { const fakeNetworkError: errorType = { name: 'fakeNetworkError', message: 'Network error' } const fakeLockError: errorType = { name: 'fakeLockError', message: 'Error - Lock - Network error' } // Mock the transferMoney function to fail twice and succeed on the third try const mockTransferMoney = sandbox.stub(modUser, 'transferMoney') mockTransferMoney.onFirstCall().throws(new Error(fakeLockError.message)) mockTransferMoney.onSecondCall().throws(new Error(fakeNetworkError.message)) mockTransferMoney.onThirdCall().resolves(true) const mockWarnLogger = sandbox.stub(logger, 'warn') const mockErrorLogger = sandbox.stub(logger, 'error') // Call the transferMoneyWithRetry function try { await transferMoneyWithRetry(moneyTypesO.soft_currency, 'giver123', 'recipient456', 100, 300) } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.isTrue(err.message.includes('Network error')) sandbox.assert.calledTwice(mockTransferMoney) sandbox.assert.calledWithExactly(mockTransferMoney, moneyTypesO.soft_currency, 'giver123', 'recipient456', 100) sandbox.assert.calledOnce(mockWarnLogger) sandbox.assert.calledOnce(mockErrorLogger) } }) it('Failure - Transfer fail (Maximum retries exceeded)', async () => { const mockTransferMoney = sandbox.stub(modUser, 'transferMoney') mockTransferMoney.onFirstCall().throws(new Error('Error - Lock - Network error')) mockTransferMoney.onSecondCall().throws(new Error('Error - Lock - Network error')) mockTransferMoney.onThirdCall().throws(new Error('Error - Lock - Network error')) // mockTransferMoney.onCall(4).throws(new Error("Error - Lock - Network error")) // mockTransferMoney.onCall(5).throws(new Error("Error - Lock - Network error")) // mockTransferMoney.onCall(6).throws(new Error("Error - Lock - Network error")) // mockTransferMoney.onCall(7).resolves(true) const mockWarnLogger = sandbox.stub(logger, 'warn') const mockErrorLogger = sandbox.stub(logger, 'error') // Call the transferMoneyWithRetry function const maxAttempt = 3 const amountToTransfer = 130 const delay = 10 try { await transferMoneyWithRetry(moneyTypesO.soft_currency, 'giver123', 'recipient456', amountToTransfer, delay, maxAttempt) } catch (err) { if (!(err instanceof Error) || err?.message === null) { chai.assert.fail('Please use a correct error format') } chai.assert.include(err.message, transferMoneyWithRetryErrors.ErrorMaxRetry!.message) sandbox.assert.callCount(mockTransferMoney, maxAttempt) sandbox.assert.calledWithExactly(mockTransferMoney, moneyTypesO.soft_currency, 'giver123', 'recipient456', amountToTransfer) sandbox.assert.called(mockWarnLogger) sandbox.assert.called(mockErrorLogger) } }) }) }) ------- file: ./tests/performance/presentation_routes_user.test.ts ------- import chai from 'chai' import { expect } from 'chai' import { describe, it } from 'mocha' import { DockerComposeEnvironment, PullPolicy, StartedDockerComposeEnvironment, Wait } from 'testcontainers' import { exec } from 'child_process' import { promisify } from 'util' const execAsync = promisify(exec) const DB_READY_WAIT_MS = 30000 describe('Performance tests - presentation:routes:user', () => { // Dont accidentally fetch the real database (use the containerized test environment) ! process.env.DB_URI = '' process.env.DB_HOST = '' // This variable will store the test environment from the docker-compose let dockerComposeEnvironment: StartedDockerComposeEnvironment const originalEnv = { ...process.env } // This is a portfolio API, in a real project, use a .env ! const test_env: Record<string, string> = { DB_DRIVER: 'mysql', DB_USERNAME: 'mysql', DB_PASSWORD: 'mypass', DB_DATABASE_NAME: 'mydbuser', DB_PORT: '3306', DOCKER_APP_NETWORK: 'my_app_network', API_PORT: '8080', LOGLEVEL: 'debug' } process.env = { ...process.env, ...test_env } let appUrl: string = '' before(async () => { const composeFilePath: string = '.' const composeFile: string = 'docker-compose.yaml' try { dockerComposeEnvironment = await new DockerComposeEnvironment(composeFilePath, composeFile) .withPullPolicy(PullPolicy.defaultPolicy()) .withEnvironment(test_env) .withWaitStrategy('app-1', Wait.forLogMessage('app running')) .withWaitStrategy('db-1', Wait.forLogMessage('ready for connections')) .up(['app']) await new Promise((resolve) => setTimeout(resolve, DB_READY_WAIT_MS)) } catch (error) { chai.assert.fail(`Container test environment setup failed: ${String(error)}`) } const appContainer = dockerComposeEnvironment.getContainer('app-1') const appPort = Number(process.env.API_PORT) || 8080 appUrl = `http://${appContainer.getHost()}:${appContainer.getMappedPort(appPort)}/api/v1/user` }) after(async () => { await dockerComposeEnvironment.down() // Cancel the modification of the env variable process.env = originalEnv // logger.info("Docker Compose test environment stopped for integration tests on user/.") }) describe('routes > user > /user GET', () => { it('Should maintain stable memory usage under load', async () => { const cmd = `npx autocannon -c 50 -d 5 -m GET "${appUrl}"` const { stderr } = await execAsync(cmd, { maxBuffer: 10 * 1024 * 1024 }) // Look for key performance indicators expect(stderr).to.include('requests in') expect(stderr).not.to.include('errors') // Parse the output to get specific metrics const avgLatencyLine = stderr.split('\n').at(7) if (!avgLatencyLine) expect.fail('wrong format for result line') const avgLatencyLineValues = avgLatencyLine.split('│') if (avgLatencyLineValues instanceof Array) { const avgLatencyStr = avgLatencyLineValues[6] if (!avgLatencyStr) expect.fail('invalid value for avg latency') const avgLatency = parseFloat(avgLatencyStr) expect(avgLatency).to.be.below(1500) } else { expect.fail('Average latency not found in autocannon output.') } }) }) }) ------- file: ./project_mini.log ------- ------- file: ./README.md ------- # REST API nodejs - typescript ## Skills - **Clean architecture** (onion architecture) - CI/CD pipeline with **github actions** - test, build docker image, deploy docker image to **docker hub** - Testing using **sinon.js** and **mocha** - Mocks - Coverage - Unit tests - Integration tests with **testcontainers** and **supertest** - Persistence with **typeorm** - Entities handling - Table join - Table lock - Transactions (rollback and commit) - Observability **opentelemetry** - log with **loki** - metrics with **prometheus** - traces with **tempo** - dashboard with grafana - Streams - Pipeline handling - Transformation - Async generators - Documentation with **Swagger** - **Docker** - docker-compose.yaml - Dockerfile - Logging with **Winston** - Validation using **Zod** - **Typescript** ## Description This repository is a backend rest api portfolio that has a few routes (CRUD) aiming to keep at-hand backend development techniques and show off dev skills. To make things easier for github users, there in no need for a .env, easier to test and deploy for external users who want to try it. ## Prerequisites - Having git installed - Having npm(v6+) & npx installed - Having docker(v27+) installed !! A docker group must be created, then your user(as a sudoer) musty be added to it. Otherwise you'll have trouble launching the tests !! Link to install and configure docker properly : https://medium.com/devops-technical-notes-and-manuals/how-to-run-docker-commands-without-sudo-28019814198f Don't forgot to restart your computer or session for the changes to be available on all shells ## Git Installation - Clone the project `git clone https://github.com/gary003/rest_api_nodejs_typescript.git` - Go into the project directory `cd rest_api_nodejs_typescript` - Install the dependences `npm install` ## Start API - Launch the app & DB (mysql) In a shell, at the root directory of the project, type `npm run start` or `docker compose up` - OpenAPI (swagger) Copy this url in a browser (adapt the port if needed) `localhost:8080` ## Tests + Coverage - Launch global tests `npm run test` ## Developer - Gary Johnson - mail: gary.johnson.top@gmail.com - github: https://github.com/gary003 ## License [MIT] ------- file: ./.c8rc.json ------- { "include": ["src/v1"], "thresholds": { "branches": 80, "lines": 85, "functions": 90, "statements": 85 } } ------- file: ./docker-compose.yaml ------- services: app: build: . ports: - '${API_PORT:-8080}:${API_PORT:-8080}' depends_on: - db environment: - DB_DRIVER=${DB_DRIVER:-mysql} - DB_HOST=${DB_HOST:-db} - DB_USERNAME=${DB_USERNAME:-mysql} - DB_PASSWORD=${DB_PASSWORD:-mypass} - DB_DATABASE_NAME=${DB_DATABASE_NAME:-mydb} - DB_PORT=${DB_PORT:-3306} - CRYPTO_SECRET_KEY=${CRYPTO_SECRET_KEY:-4876he526d9148b7ac40bd623b240753} - API_PORT=${API_PORT:-8080} - LOGLEVEL=${LOGLEVEL:-debug} restart: always networks: - my_app_network - my_db_network db: image: mysql:latest restart: always environment: - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASSWORD:-StrongRootPassword123!} - MYSQL_USER=${DB_USERNAME:-mysql} - MYSQL_PASSWORD=${DB_PASSWORD:-mypass} - MYSQL_DATABASE=${DB_DATABASE_NAME:-mydb} volumes: - ./src/v1/infrastructure/persistence/database/db_volume:/var/lib/mysql - ./src/v1/infrastructure/persistence/database/db_scripts/:/docker-entrypoint-initdb.d/ ports: - '${DB_PORT:-3306}:${DB_PORT:-3306}' healthcheck: test: ['CMD', 'mysqladmin', 'ping', '-h', 'localhost'] timeout: 20s retries: 10 networks: - my_db_network otel-collector: image: otel/opentelemetry-collector-contrib:latest command: ['--config=/etc/otel-config.yaml'] volumes: - ./src/v1/infrastructure/observability/otel-collector-config.yaml:/etc/otel-config.yaml ports: - '4317:4317' # OTLP gRPC (host:container) - '4318:4318' # OTLP HTTP (host:container) - '13133:13133' # health_check - '8889:8889' # Prometheus metrics healthcheck: test: ['CMD', 'curl', '-f', 'http://localhost:13133/livez'] interval: 30s timeout: 10s retries: 3 # depends_on: # - loki networks: - my_app_network - my_observability_network loki: image: grafana/loki:latest ports: - '3100:3100' # expose Loki to host command: -config.file=/etc/loki/local-config.yaml volumes: - ./src/v1/infrastructure/observability/loki-config.yaml:/etc/loki/local-config.yaml healthcheck: test: ['CMD', 'wget', '--no-verbose', '--spider', 'http://localhost:3100/ready'] interval: 10s timeout: 10s retries: 10 start_period: 20s networks: - my_observability_network prometheus: image: prom/prometheus:latest volumes: - ./src/v1/infrastructure/observability/prometheus.yml:/etc/prometheus/prometheus.yml ports: - '9090:9090' networks: - my_observability_network tempo: image: grafana/tempo:latest command: ['-config.file=/etc/tempo.yaml'] ports: - '3200' # Tempo HTTP API - '4317' # OTLP gRPC (internal only) volumes: - ./src/v1/infrastructure/observability/tempo.yaml:/etc/tempo.yaml - tempo_data:/var/tempo healthcheck: test: ['CMD', 'curl', '-f', 'http://localhost:3200/status'] interval: 10s timeout: 5s retries: 5 networks: - my_observability_network grafana: image: grafana/grafana:latest container_name: grafana depends_on: - loki - prometheus - tempo volumes: - grafana_data:/var/lib/grafana # Mount provisioning datasources - ./src/v1/infrastructure/observability/grafana-datasources.yaml:/etc/grafana/provisioning/datasources/datasources.yaml:ro environment: # Less chatty log at startup - GF_LOG_LEVEL=warn - GF_LOG_MODE=console # Enable anonymous access (Admin role, no login form) - GF_AUTH_ANONYMOUS_ENABLED=true - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin - GF_AUTH_DISABLE_LOGIN_FORM=true # Enable TraceQL editor - GF_FEATURE_TOGGLES_ENABLE=traceqlEditor # Install required plugins - GF_INSTALL_PLUGINS=grafana-exploretraces-app # Optional: allow provisioning overwrite (helpful in dev) - GF_PROVISIONING_ALLOW_OVERWRITE=true ports: - '3000:3000' networks: - my_observability_network networks: my_app_network: driver: bridge my_db_network: driver: bridge my_observability_network: driver: bridge volumes: grafana_data: tempo_data: ------- file: ./tsconfig.json ------- { "compilerOptions": { /* Visit https://aka.ms/tsconfig.json to read more about this file */ /* Projects */ // "incremental": true, /* Enable incremental compilation */ // "composite": true, /* Enable constraints that allow a TypeScript project to be used with project references. */ // "tsBuildInfoFile": "./", /* Specify the folder for .tsbuildinfo incremental compilation files. */ // "disableSourceOfProjectReferenceRedirect": true, /* Disable preferring source files instead of declaration files when referencing composite projects */ // "disableSolutionSearching": true, /* Opt a project out of multi-project reference checking when editing. */ // "disableReferencedProjectLoad": true, /* Reduce the number of projects loaded automatically by TypeScript. */ /* Language and Environment */ "target": "es2017" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */, // "lib": [], /* Specify a set of bundled library declaration files that describe the target runtime environment. */ // "jsx": "preserve", /* Specify what JSX code is generated. */ "experimentalDecorators": true /* Enable experimental support for TC39 stage 2 draft decorators. */, "emitDecoratorMetadata": true /* Emit design-type metadata for decorated declarations in source files. */, // "jsxFactory": "", /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */ // "jsxFragmentFactory": "", /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */ // "jsxImportSource": "", /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */ // "reactNamespace": "", /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */ // "noLib": true, /* Disable including any library files, including the default lib.d.ts. */ // "useDefineForClassFields": true, /* Emit ECMAScript-standard-compliant class fields. */ /* Modules */ "module": "commonjs" /* Specify what module code is generated. */, // "rootDir": "./src" /* Specify the root folder within your source files. */, "moduleResolution": "node" /* Specify how TypeScript looks up a file from a given module specifier. */, // "baseUrl": "./", /* Specify the base directory to resolve non-relative module names. */ // "paths": {}, /* Specify a set of entries that re-map imports to additional lookup locations. */ // "rootDirs": [], /* Allow multiple folders to be treated as one when resolving modules. */ // "typeRoots": [], /* Specify multiple folders that act like `./node_modules/@types`. */ // "types": [], /* Specify type package names to be included without being referenced in a source file. */ // "allowUmdGlobalAccess": true, /* Allow accessing UMD globals from modules. */ "resolveJsonModule": true /* Enable importing .json files */, // "noResolve": true, /* Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. */ /* JavaScript Support */ // "allowJs": true, /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */ // "checkJs": true, /* Enable error reporting in type-checked JavaScript files. */ // "maxNodeModuleJsDepth": 1, /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */ /* Emit */ // "declaration": true, /* Generate .d.ts files from TypeScript and JavaScript files in your project. */ // "declarationMap": true, /* Create sourcemaps for d.ts files. */ // "emitDeclarationOnly": true, /* Only output d.ts files and not JavaScript files. */ // "sourceMap": true, /* Create source map files for emitted JavaScript files. */ // "outFile": "./", /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */ "outDir": "./dist" /* Specify an output folder for all emitted files. */, // "removeComments": true, /* Disable emitting comments. */ // "noEmit": true, /* Disable emitting files from a compilation. */ // "importHelpers": true, /* Allow importing helper functions from tslib once per project, instead of including them per-file. */ // "importsNotUsedAsValues": "remove", /* Specify emit/checking behavior for imports that are only used for types */ // "downlevelIteration": true, /* Emit more compliant, but verbose and less performant JavaScript for iteration. */ // "sourceRoot": "", /* Specify the root path for debuggers to find the reference source code. */ // "mapRoot": "", /* Specify the location where debugger should locate map files instead of generated locations. */ // "inlineSourceMap": true, /* Include sourcemap files inside the emitted JavaScript. */ // "inlineSources": true, /* Include source code in the sourcemaps inside the emitted JavaScript. */ // "emitBOM": true, /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */ // "newLine": "crlf", /* Set the newline character for emitting files. */ // "stripInternal": true, /* Disable emitting declarations that have `@internal` in their JSDoc comments. */ // "noEmitHelpers": true, /* Disable generating custom helper functions like `__extends` in compiled output. */ // "noEmitOnError": true, /* Disable emitting files if any type checking errors are reported. */ // "preserveConstEnums": true, /* Disable erasing `const enum` declarations in generated code. */ // "declarationDir": "./", /* Specify the output directory for generated declaration files. */ /* Interop Constraints */ // "isolatedModules": true, /* Ensure that each file can be safely transpiled without relying on other imports. */ // "allowSyntheticDefaultImports": true, /* Allow 'import x from y' when a module doesn't have a default export. */ "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */, // "preserveSymlinks": true, /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */ "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */, /* Type Checking */ "strict": true /* Enable all strict type-checking options. */, // "noImplicitAny": true, /* Enable error reporting for expressions and declarations with an implied `any` type.. */ // "strictNullChecks": true, /* When type checking, take into account `null` and `undefined`. */ // "strictFunctionTypes": true, /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */ // "strictBindCallApply": true, /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */ // "strictPropertyInitialization": true, /* Check for class properties that are declared but not set in the constructor. */ // "noImplicitThis": true, /* Enable error reporting when `this` is given the type `any`. */ // "useUnknownInCatchVariables": true, /* Type catch clause variables as 'unknown' instead of 'any'. */ "alwaysStrict": true /* Ensure 'use strict' is always emitted. */, // "noUnusedLocals": true /* Enable error reporting when a local variables aren't read. */, // "noUnusedParameters": true, /* Raise an error when a function parameter isn't read */ // "exactOptionalPropertyTypes": true, /* Interpret optional property types as written, rather than adding 'undefined'. */ "noImplicitReturns": true /* Enable error reporting for codepaths that do not explicitly return in a function. */, // "noFallthroughCasesInSwitch": true, /* Enable error reporting for fallthrough cases in switch statements. */ "noUncheckedIndexedAccess": true /* Include 'undefined' in index signature results */, // "noImplicitOverride": true, /* Ensure overriding members in derived classes are marked with an override modifier. */ // "noPropertyAccessFromIndexSignature": true, /* Enforces using indexed accessors for keys declared using an indexed type */ // "allowUnusedLabels": true, /* Disable error reporting for unused labels. */ // "allowUnreachableCode": true, /* Disable error reporting for unreachable code. */ /* Completeness */ // "skipDefaultLibCheck": true, /* Skip type checking .d.ts files that are included with TypeScript. */ "skipLibCheck": true /* Skip type checking all .d.ts files. */ }, "include": ["./src/**/*"] } ------- file: ./src/app.ts ------- require('dotenv').config() import express from 'express' import userRoute from './v1/presentation/routes/user/index' import swaggerUi from 'swagger-ui-express' import apiDocumentation from './v1/helpers/apiDocumentation/v2' // import { openApiOptions } from './v1/helpers/apiDocumentation/v3/docOptions' import openApiSpec from './v1/helpers/apiDocumentation/v3' import compression from 'compression' import helmet from 'helmet' import cors from 'cors' import logger from './v1/helpers/logger' import rateLimit from 'express-rate-limit' const app = express() const urlBase: string = 'api/v1' if (!process.env.production) { // openAPI V2 app.use(`/${urlBase}/doc2/apiDocumentation`, swaggerUi.serve, swaggerUi.setup(apiDocumentation)) // openAPI V3 // app.use('/apiDocV3', swaggerUi.serve, swaggerUi.setup(openApiSpec, openApiOptions)) app.use(`/${urlBase}/doc3/apiDocumentation`, swaggerUi.serve, swaggerUi.setup(openApiSpec)) } app.use(compression()) app.use(helmet()) app.use(cors()) app.use(express.json()) app.use(rateLimit({ windowMs: 15 * 60 * 1000, max: 100 })) // 100 req/15min // Redirect root URL to /apiDocV3 app.get('/', (req, res) => { return res.status(300).redirect(`/${urlBase}/doc3/apiDocumentation`) }) app.use(`/${urlBase}/user`, userRoute) const handleNotFound = (req: express.Request, res: express.Response, next: express.NextFunction) => { // Check if any route handler has already handled the request if (res.headersSent) { return next() // Let other error handlers handle it if already responded to } return res.status(404).json({ message: 'Not Found' }) } const handleError = (err: Error, req: express.Request, res: express.Response) => { logger.error(err.stack) // Log the error for debugging // Set default status code to 500 (Internal Server Error) let statusCode = 500 // Map specific error types to appropriate status codes if (err.name === 'ValidationError') { statusCode = 400 // Bad request for validation errors } else if (err.name === 'UnauthorizedError') { statusCode = 401 // Unauthorized for authentication errors } else if (err.name === 'ForbiddenError') { statusCode = 403 // Forbidden for authorization errors } // Craft a generic error response with optional details based on environment const errorResponse = { message: 'Internal Server Error', // Default message error: '' } if (process.env.NODE_ENV === 'development') { errorResponse.error = err.message // Include more details in development } res.status(statusCode).json(errorResponse) } // Not found handler app.use(handleNotFound) // Error handler middleware app.use(handleError) export default app ------- file: ./src/v1/services/wallet/dto.ts ------- export type wallet = { walletId: string hardCurrency?: number softCurrency?: number } ------- file: ./src/v1/services/user/error.dto.ts ------- import { errorType } from '../../domain/error' export const transferMoneyErrors: Record<string, errorType> = { ErrorParamsValidator: { name: 'ErrorParamsValidator', message: 'Error - Failed to retrieve recipient - giver informations' } as const, ErrorLockAcquisition: { name: 'ErrorLockAcquisition', message: 'Error - Lock - Failed to acquire locks on wallets' } as const, ErrorTransactionCreation: { name: 'ErrorTransactionCreation', message: 'Error - Failed to create database transaction' } as const, ErrorUpdateGiverWallet: { name: 'ErrorUpdateGiverWallet', message: 'Error - Failed to update giver wallet balance' } as const, ErrorUpdateRecipientWallet: { name: 'ErrorUpdateRecipientWallet', message: 'Error - Failed to update recipient wallet balance' } } as const export const userFunctionsErrors: Record<string, errorType> = { ErrorRetrievingUsers: { name: 'ErrorRetrievingUsers', message: 'Error - Failed to retrieve users from database' } as const, ErrorGettingWalletInfo: { name: 'ErrorGettingWalletInfo', message: 'Error - no wallet ibfo found' } as const, ErrorNoWalletUser: { name: 'ErrorNoWalletUser', message: 'Error - User with no wallet' } as const, ErrorCreatingUser: { name: 'ErrorCreatingUser', message: 'Error - Failed to create a new user' } as const, ErrorUpdatingWallet: { name: 'ErrorUpdatingWallet', message: 'Error - Failed to update user wallet' } as const, ErrorDeletingUser: { name: 'ErrorDeletingUser', message: 'Error - Failed to delete user' } as const, ErrorFetchingUserInfo: { name: 'ErrorFetchingUserInfo', message: 'Error - Failed to fetch user information' } as const } as const export const moneyTransferParamsValidatorErrors: Record<string, errorType> = { ErrorUserInfo: { name: 'ErrorUserInfo', message: 'Impossible to get user info from db' }, ErrorCurrencyType: { name: 'ErrorCurrencyType', message: 'wrong type of currency' }, ErrorInvalidAmount: { name: 'ErrorInvalidAmount', message: 'Error - The transfer amount should be a number and >= 1' }, ErrorInsufficientFunds: { name: 'ErrorInsufficientFunds', message: 'Error - Insufficient funds in giver wallet' } } as const export const transferMoneyWithRetryErrors: Record<string, errorType> = { ErrorMaxRetry: { name: 'ErrorMaxRetry', message: 'Transfer failed - Max retry attempt reached' } } as const ------- file: ./src/v1/services/user/index.ts ------- import { acquireLockOnWallet, commitAndQuitTransactionRunner, createAndStartTransaction, rollBackAndQuitTransactionRunner } from '../../infrastructure/persistence/database/db_connection/connectionFile' import { getAllCustomersDB, getCustomerWalletInfoDB, saveNewCustomerDB, deleteCustomerByIdDB, getAllUsersStreamDB } from '../../infrastructure/persistence/database/customer' import { updateWalletByWalletIdDB, updateWalletByWalletIdTransaction } from '../../infrastructure/persistence/database/wallet' import { moneyTypes, moneyTypesO } from '../../domain' import { userWalletDTO } from './dto' import { transferMoneyErrors, userFunctionsErrors, moneyTransferParamsValidatorErrors, transferMoneyWithRetryErrors } from './error.dto' import logger from '../../helpers/logger' import { errorType } from '../../domain/error' /** * Retrieves all users along with their wallet information. * @returns {Promise<userWalletDTO[]>} - A list of users with their wallets. * @throws {Error} - If the database query fails. */ export const getAllUsers = async (): Promise<userWalletDTO[]> => { const allUsers = await getAllCustomersDB().catch((err: unknown) => err) if (allUsers instanceof Error) { // Log and throw an error if the database query fails const allUsersError = `serviceError: ${userFunctionsErrors.ErrorRetrievingUsers!.message} \n databaseError: ${String(allUsers)}` logger.error(allUsersError) throw new Error(allUsersError) } return allUsers as unknown as userWalletDTO[] } /** * Retrieves all users as a stream for efficient handling of large datasets. * @returns {Promise<ReadableStream>} - A stream of users with their wallets. * @throws {Error} - If the database query fails. */ export const getAllUsersStream = async () => { const streamUsers = await getAllUsersStreamDB().catch((err) => err) if (streamUsers instanceof Error) { // Log and throw an error if the stream query fails const errorStream = `serviceError: ${userFunctionsErrors.ErrorRetrievingUsers!.message} \n databaseError: ${String(streamUsers)}` logger.error(errorStream) throw new Error(errorStream) } return streamUsers } /** * Saves a new user to the database. * @param {string} firstname - The first name of the user. * @param {string} lastname - The last name of the user. * @returns {Promise<userWalletDTO>} - The newly created user. * @throws {Error} - If the user creation fails. */ export const saveNewUser = async (firstname: string, lastname: string): Promise<userWalletDTO> => { const newUser = await saveNewCustomerDB(firstname, lastname).catch((err) => err) if (newUser instanceof Error) { // Log and throw an error if user creation fails const saveError = `serviceError: ${userFunctionsErrors.ErrorCreatingUser!.message} \n databaseError: ${String(newUser)}` logger.error(saveError) throw new Error(saveError) } return newUser as unknown as userWalletDTO } /** * Adds currency to a user's wallet. * @param {string} userId - The ID of the user. * @param {moneyTypes} currencyType - The type of currency to add (e.g., hard_currency, soft_currency). * @param {number} amount - The amount of currency to add. * @returns {Promise<boolean>} - True if the update is successful. * @throws {Error} - If the amount is invalid, the currency type is invalid, or the update fails. */ export const addCurrency = async (userId: string, currencyType: moneyTypes, amount: number): Promise<boolean> => { // Validate the amount and currency type if (amount <= 0) throw new Error(`serviceError: ${moneyTransferParamsValidatorErrors.ErrorInvalidAmount!.message}`) if (!Object.values(moneyTypesO).includes(currencyType)) throw new Error(`serviceError: ${moneyTransferParamsValidatorErrors.ErrorCurrencyType!.message}`) // Retrieve the user's wallet information const currentUserWalletInfo = await getUserWalletInfo(userId).catch((err) => err) if (currentUserWalletInfo instanceof Error) { // Log and throw an error if the wallet info retrieval fails const userInfoError = `serviceError: ${userFunctionsErrors.ErrorGettingWalletInfo!.message} \n databaseError: ${String(currentUserWalletInfo)}` logger.error(userInfoError) throw new Error(userInfoError) } // Ensure the user has a wallet if (!currentUserWalletInfo.Wallet) { logger.error(userFunctionsErrors.ErrorNoWalletUser!.message) throw new Error(`serviceError: ${userFunctionsErrors.ErrorNoWalletUser!.message}`) } // Update the wallet with the new balance const resultUpdate = await updateWalletByWalletIdDB( String(currentUserWalletInfo.Wallet.walletId), currencyType, Number(currentUserWalletInfo.Wallet[currencyType]) + amount ).catch((err) => err) if (resultUpdate instanceof Error) { // Log and throw an error if the wallet update fails logger.error(userFunctionsErrors.ErrorUpdating!.message) logger.error(resultUpdate) throw new Error(`serviceError: ${userFunctionsErrors.ErrorUpdating!.message}`) } return true } /** * Deletes a user by their ID. * @param {string} userId - The ID of the user to delete. * @returns {Promise<boolean>} - True if the deletion is successful. * @throws {Error} - If the deletion fails. */ export const deleteUserById = async (userId: string): Promise<boolean> => { const deletedUser = await deleteCustomerByIdDB(userId).catch((err: Error) => err) if (deletedUser instanceof Error) { // Log and throw an error if the deletion fails const deleteError = `serviceError: ${userFunctionsErrors.ErrorDeletingUser!.message} \n databaseError: ${String(deletedUser)}` logger.error(deleteError) throw new Error(deleteError) } return deletedUser } /** * Retrieves a user's wallet information by their ID. * @param {string} userId - The ID of the user. * @returns {Promise<userWalletDTO>} - The user's wallet information. * @throws {Error} - If the wallet info retrieval fails. */ export const getUserWalletInfo = async (userId: string): Promise<userWalletDTO> => { const userWalletI = await getCustomerWalletInfoDB(userId).catch((err) => err) if (userWalletI instanceof Error) { // Log and throw an error if the wallet info retrieval fails const fetchError = `serviceError: ${userFunctionsErrors.ErrorFetchingUserInfo!.message} \n databaseError: ${String(userWalletI)}` logger.error(fetchError) throw new Error(fetchError) } return userWalletI } /** * Validates the parameters for a money transfer. * @param {moneyTypes} currency - The type of currency to transfer. * @param {string} giverId - The ID of the user sending the money. * @param {string} recipientId - The ID of the user receiving the money. * @param {number} amount - The amount of money to transfer. * @returns {Promise<userWalletDTO[]>} - The wallet information for both the giver and recipient. * @throws {Error} - If the parameters are invalid or the wallet info retrieval fails. */ export const transferMoneyParamsValidator = async (currency: moneyTypes, giverId: string, recipientId: string, amount: number): Promise<userWalletDTO[]> => { // Validate the currency type if (!Object.values(moneyTypesO).includes(currency)) throw new Error(`serviceError: ${moneyTransferParamsValidatorErrors.ErrorCurrencyType!.message}`) // Retrieve the giver's wallet information const giverUserInfo = await getCustomerWalletInfoDB(giverId).catch((error) => error) if (giverUserInfo instanceof Error) { // Log and throw an error if the giver's wallet info retrieval fails const giverUserInfoError = `serviceError: ${moneyTransferParamsValidatorErrors.ErrorUserInfo!.message} \n databaseError: ${String(giverUserInfo)}` logger.error(giverUserInfoError) throw new Error(giverUserInfoError) } // Ensure the giver has a wallet if (!giverUserInfo.Wallet) { const error = `serviceError: ${userFunctionsErrors.ErrorNoWalletUser!.message} \n databaseError: ${String(giverUserInfo)}` logger.error(error) throw new Error(error) } // Calculate the giver's new balance after the transfer const giverNewBalance = Number(giverUserInfo.Wallet[currency]) - amount // Ensure the giver has sufficient funds if (giverNewBalance < 0) { throw new Error(`serviceError: ${moneyTransferParamsValidatorErrors.ErrorInsufficientFunds!.message}`) } // Retrieve the recipient's wallet information const recipientUserInfo = await getCustomerWalletInfoDB(recipientId).catch((error: Error) => error) if (recipientUserInfo instanceof Error) { // Log and throw an error if the recipient's wallet info retrieval fails const recipientUserInfoError = `serviceError: ${moneyTransferParamsValidatorErrors.ErrorUserInfo!.message} \n databaseError: ${String(recipientUserInfo)}` logger.error(recipientUserInfo) throw new Error(recipientUserInfoError) } // Ensure the recipient has a wallet if (!recipientUserInfo.Wallet) { const error = `serviceError: ${userFunctionsErrors.ErrorNoWalletUser!.message} \n databaseError: ${String(recipientUserInfo)}` logger.error(error) throw new Error(error) } return [giverUserInfo, recipientUserInfo] } /** * Transfers money between two users' wallets. * @param {moneyTypes} currency - The type of currency to transfer. * @param {string} giverId - The ID of the user sending the money. * @param {string} recipientId - The ID of the user receiving the money. * @param {number} amount - The amount of money to transfer. * @returns {Promise<boolean>} - True if the transfer is successful. * @throws {Error} - If the transfer fails at any step. */ export const transferMoney = async (currency: moneyTypes, giverId: string, recipientId: string, amount: number): Promise<boolean> => { // Validate the transfer parameters const res = await transferMoneyParamsValidator(currency, giverId, recipientId, amount).catch((err) => err) if (res instanceof Error) { // Log and throw an error if the parameter validation fails const paramError = `serviceError: ${transferMoneyErrors.ErrorParamsValidator!.message} \n databaseError: ${String(res)}` logger.error(paramError) throw new Error(paramError) } const [giverUserInfo, recipientUserInfo]: userWalletDTO[] = res if (!giverUserInfo || !recipientUserInfo) { // Log and throw an error if the giver or recipient info is missing logger.error(transferMoneyErrors.ErrorParamsValidator!.message) throw new Error(`serviceError: ${transferMoneyErrors.ErrorParamsValidator!.message}`) } // Start a database transaction const transacRunner = await createAndStartTransaction().catch((err) => err) if (transacRunner instanceof Error) { // Log and throw an error if the transaction creation fails const transacRunnerError = `serviceError: ${transferMoneyErrors.ErrorTransactionCreation!.message} \n databaseError: ${String(transacRunner)}` logger.error(transacRunnerError) throw new Error(transacRunnerError) } // Acquire locks on the giver and recipient wallets to prevent concurrent updates const lockResultGiver = await acquireLockOnWallet(transacRunner, String(giverUserInfo.Wallet.walletId)).catch((err) => err) const lockResultRecipient = await acquireLockOnWallet(transacRunner, String(recipientUserInfo.Wallet.walletId)).catch((err) => err) if (lockResultGiver instanceof Error || lockResultRecipient instanceof Error) { // Log and throw an error if the lock acquisition fails const errorStr = !lockResultGiver ? String(lockResultGiver) : String(lockResultRecipient) const errorLock = `serviceError: ${transferMoneyErrors.ErrorLockAcquisition!.message} - ${errorStr}` logger.error(errorLock) throw new Error(errorLock) } // Update the giver's wallet with the new balance const giverNewBalance: number = Number(giverUserInfo.Wallet[currency]) - amount const updateWalletGiverResult = await updateWalletByWalletIdTransaction(transacRunner, String(giverUserInfo.Wallet.walletId), currency, giverNewBalance).catch((err) => err) if (updateWalletGiverResult instanceof Error) { // Log and throw an error if the giver's wallet update fails const updateError = `serviceError: ${transferMoneyErrors.ErrorUpdateGiverWallet!.message} \n databaseError: ${updateWalletGiverResult.message}` logger.error(updateError) rollBackAndQuitTransactionRunner(transacRunner) throw new Error(updateError) } // Update the recipient's wallet with the new balance const recipientNewBalance: number = Number(recipientUserInfo.Wallet[currency]) + amount const updateWalletRecipientResult = await updateWalletByWalletIdTransaction(transacRunner, String(recipientUserInfo.Wallet.walletId), currency, recipientNewBalance).catch( (err) => err ) if (updateWalletRecipientResult instanceof Error) { // Log and throw an error if the recipient's wallet update fails const updateWalletRecipientError = `serviceError: ${transferMoneyErrors.ErrorUpdateRecipientWallet!.message} \n databaseError: ${String(updateWalletRecipientResult)}` logger.error(updateWalletRecipientError) rollBackAndQuitTransactionRunner(transacRunner) throw new Error(updateWalletRecipientError) } // Commit the transaction if everything is successful commitAndQuitTransactionRunner(transacRunner) return true } /** * Transfers money between two users' wallets with retry logic for transient errors. * @param {moneyTypes} currency - The type of currency to transfer. * @param {string} giverId - The ID of the user sending the money. * @param {string} recipientId - The ID of the user receiving the money. * @param {number} amount - The amount of money to transfer. * @param {number} delayTime - The initial delay between retries (in milliseconds). * @param {number} maxRetries - The maximum number of retry attempts. * @param {number} attempt - The current retry attempt. * @returns {Promise<boolean>} - True if the transfer is successful. * @throws {Error} - If the transfer fails after the maximum number of retries. */ export const transferMoneyWithRetry = async ( currency: moneyTypes, giverId: string, recipientId: string, amount: number, delayTime = 300, maxRetries = 3, attempt = 1 ): Promise<boolean> => { try { // Attempt the transfer return await transferMoney(currency, giverId, recipientId, amount) } catch (err) { // Stop retrying if the maximum number of attempts is reached if (attempt >= maxRetries) { logger.error(`Transfer failed - Max retry attempt reached: ${attempt} attempts`) throw new Error(`serviceError: ${transferMoneyWithRetryErrors.ErrorMaxRetry!.message} \n maxRetries: ${maxRetries}`) } const errInfo = err as errorType // Retry if the error is related to a lock (transient error) if (!!errInfo && errInfo.message.includes('Error - Lock')) { const delay = delayTime * 2 ** (attempt - 1) logger.warn(`Transfer failed, retrying in ${delay}ms (attempt ${attempt}/${maxRetries})`) await new Promise((resolve) => setTimeout(resolve, delay)) return transferMoneyWithRetry(currency, giverId, recipientId, amount, delay, maxRetries, attempt + 1) } // Re-throw non-retryable errors logger.error(errInfo.message) throw new Error(errInfo.message) } } ------- file: ./src/v1/services/user/dto.ts ------- import { wallet } from '../wallet/dto' export type userWalletDTO = { userId: string firstname: string lastname: string Wallet: wallet } ------- file: ./src/v1/infrastructure/observability/otel-collector-config.yaml ------- extensions: health_check: {} zpages: {} receivers: otlp: protocols: grpc: http: exporters: otlphttp/tempo: endpoint: http://tempo:4318 tls: insecure: true otlphttp/loki: endpoint: http://loki:3100/loki/api/v1/push tls: insecure: true labels: job: otel-logs prometheus: endpoint: 0.0.0.0:8889 namespace: otel const_labels: exporter: otel-collector debug: verbosity: detailed processors: batch: timeout: 1s send_batch_size: 100 service: pipelines: traces: receivers: [otlp] processors: [batch] exporters: [otlphttp/tempo] metrics: receivers: [otlp] processors: [batch] exporters: [prometheus] logs: receivers: [otlp] processors: [batch] exporters: [debug, otlphttp/loki] ------- file: ./src/v1/infrastructure/observability/grafana-datasources.yaml ------- apiVersion: 1 datasources: - name: Prometheus type: prometheus uid: prometheus access: proxy orgId: 1 url: http://prometheus:9090 basicAuth: false isDefault: false version: 1 editable: false jsonData: httpMethod: GET - name: Tempo type: tempo uid: tempo access: proxy orgId: 1 url: http://tempo:3200 basicAuth: false isDefault: true version: 1 editable: false apiVersion: 1 jsonData: httpMethod: GET serviceMap: datasourceUid: prometheus streamingEnabled: search: true - name: Loki type: loki uid: loki access: proxy orgId: 1 url: http://loki:3100 basicAuth: false isDefault: false version: 1 editable: false jsonData: httpMethod: GET derivedFields: - datasourceUid: tempo matcherRegex: "traceID=(\\w+)" name: TraceID url: '$${__value.raw}' maxLines: 1000 # Add custom header to avoid org_id=fake httpHeaderName1: 'X-Scope-OrgID' secureJsonData: httpHeaderValue1: '1' ------- file: ./src/v1/infrastructure/observability/prometheus.yml ------- # prometheus/prometheus.yml global: scrape_interval: 15s evaluation_interval: 15s scrape_configs: - job_name: 'otel-collector' static_configs: - targets: ['otel-collector:8889'] # Scrape collector metrics - job_name: 'prometheus' static_configs: - targets: ['localhost:9090'] # Scrape itself ------- file: ./src/v1/infrastructure/observability/loki-config.yaml ------- auth_enabled: false server: http_listen_port: 3100 common: path_prefix: /tmp/loki storage: filesystem: chunks_directory: /tmp/loki/chunks rules_directory: /tmp/loki/rules replication_factor: 1 ring: instance_addr: 127.0.0.1 kvstore: store: inmemory schema_config: configs: - from: 2020-10-24 store: boltdb-shipper # Keep this for now object_store: filesystem schema: v11 # Keep this for now index: prefix: index_ period: 24h # ADD THIS NEW SECTION to disable structured metadata limits_config: allow_structured_metadata: false # <-- This is the key fix # Optional: Keep this if you want ruler: alertmanager_url: http://localhost:9093 ------- file: ./src/v1/infrastructure/observability/tempo.yaml ------- stream_over_http_enabled: true server: http_listen_port: 3200 log_level: info distributor: receivers: otlp: protocols: grpc: endpoint: 'tempo:4317' ingester: trace_idle_period: 10s max_block_bytes: 1_000_000 max_block_duration: 5m compactor: compaction: block_retention: 24h metrics_generator: registry: external_labels: source: tempo cluster: docker-compose storage: path: /var/tempo/generator/wal remote_write: - url: http://prometheus:9090/api/v1/write send_exemplars: true traces_storage: path: /var/tempo/generator/traces storage: trace: backend: local local: path: /tmp/tempo/blocks wal: path: /tmp/tempo/wal overrides: defaults: metrics_generator: processors: [service-graphs, span-metrics, local-blocks] # enables metrics generator generate_native_histograms: both ------- file: ./src/v1/infrastructure/persistence/database/customer/userWalletDB.dto.ts ------- import { userWalletDTO } from '../../../../services/user/dto' export type customerWalletDBDTO = userWalletDTO export type customerWalletFromTableDB = { customer_id: string firstname: string lastname: string Wallet: { wallet_id: string; hard_currency: number; soft_currency: number } } export type customerWalletFromTableDBStream = { customer_customer_id: string customer_firstname: string customer_lastname: string wallet_customer_id: string wallet_wallet_id: string wallet_hard_currency: number wallet_soft_currency: number } ------- file: ./src/v1/infrastructure/persistence/database/customer/entity.ts ------- import { Column, Entity, PrimaryColumn } from 'typeorm' @Entity() export class Customer { @PrimaryColumn('varchar') customer_id!: string @Column({ type: 'varchar', nullable: false }) firstname!: string @Column({ type: 'varchar', nullable: false }) lastname!: string } ------- file: ./src/v1/infrastructure/persistence/database/customer/index.ts ------- import { Wallet } from '../wallet/entity' import { createAndStartTransaction, getConnection } from '../db_connection/connectionFile' import { Customer } from './entity' import { createNewWalletDB, deleteWalletByIdDBTransaction } from '../wallet' import { pipeline } from 'stream' import logger from '../../../../helpers/logger' import { v4 as uuidv4 } from 'uuid' import { customerWalletDBDTO, customerWalletFromTableDB } from './userWalletDB.dto' import { ReadStream } from 'fs' export const getAllCustomersDBAdapter = (customerDB: customerWalletFromTableDB): customerWalletDBDTO => { return { userId: customerDB.customer_id, firstname: customerDB.firstname, lastname: customerDB.lastname, Wallet: { walletId: customerDB.Wallet.wallet_id, hardCurrency: customerDB.Wallet.hard_currency, softCurrency: customerDB.Wallet.soft_currency } } } // Get all customerss with their wallets from the database export const getAllCustomersDB = async (): Promise<customerWalletDBDTO[]> => { const connection = await getConnection() // Get DB connection const UserRepository = connection.getRepository(Customer) // Get Cusdtomer repository // Query to fetch all customers with their wallets const result = await UserRepository.createQueryBuilder('customer') .innerJoinAndMapOne('customer.Wallet', Wallet, 'wallet', 'wallet.customer_id = customer.customer_id') .getMany() .catch((err) => err) // Handle errors during query execution if (result instanceof Error) { const errorMessage = `Impossible to retrieve any customer - ${String(result)}` logger.error(errorMessage) throw new Error(errorMessage) } // Create result customers with wallets const customersResults = result.map((chunk: customerWalletFromTableDB) => { return getAllCustomersDBAdapter(chunk) }) return customersResults } // Adapts a database stream into a generator yielding JSON strings of customer data export const customerStreamAdaptor = async function* (source: ReadStream): AsyncGenerator<string> { try { // Process each chunk in the stream for await (const chunk of source) { // Map chunk to userWalletDBDTO format const adaptedData = { userId: chunk.customer_customer_id, firstname: chunk.customer_firstname, lastname: chunk.customer_lastname, Wallet: { walletId: chunk.wallet_wallet_id, hardCurrency: chunk.wallet_hard_currency, softCurrency: chunk.wallet_soft_currency } } yield `${JSON.stringify(adaptedData)}\n` } } catch (err) { logger.error(err) // Log stream processing errors throw new Error(`Stream Adaptor error - ${String(err)}`) } } // Get all customers as a stream for efficient handling of large datasets export const getAllUsersStreamDB = async () => { const connection = await getConnection() // Get DB connection const CustomerRepository = connection.getRepository(Customer) // Get User repository // Query to stream customers with their wallets const customerStream = await CustomerRepository.createQueryBuilder('customer') .innerJoinAndMapOne('customer.Wallet', Wallet, 'wallet', 'wallet.customer_id = customer.customer_id') .stream() return pipeline(customerStream, customerStreamAdaptor, (err) => err) } // Save a new customer to the database and create a wallet for them export const saveNewCustomerDB = async (firstname: string, lastname: string): Promise<Customer> => { const newCustomer = new Customer() // Create new customer entity newCustomer.customer_id = uuidv4() // Generate unique ID newCustomer.firstname = firstname newCustomer.lastname = lastname // Create a wallet for the new customer const walletCreation = await createNewWalletDB(newCustomer).catch((err) => err) // Handle wallet creation errors if (walletCreation instanceof Error) { logger.error(walletCreation) throw new Error(`Impossible to create a new wallet or customer - ${String(walletCreation)}`) } return newCustomer // Return the new customer } // Delete a customer and their associated wallet from the database export const deleteCustomerByIdDB = async (customerId: string): Promise<boolean> => { // Step 1: Get customer info const customerToDeleteInfo = await getCustomerWalletInfoDB(customerId).catch((err) => err) // Handle errors during customer info retrieval if (customerToDeleteInfo instanceof Error) { logger.error(customerToDeleteInfo) throw new Error(`Impossible to delete the customer in DB, no customer info available (step 1) - ${String(customerToDeleteInfo)}`) } // Start a transaction const queryRunner = await createAndStartTransaction() // Step 2: Delete the wallet if it exists if (customerToDeleteInfo.Wallet) { const walletDeletion = await deleteWalletByIdDBTransaction(queryRunner, String(customerToDeleteInfo.Wallet.walletId)).catch((err) => err) // Handle wallet deletion errors if (walletDeletion instanceof Error) { logger.error(walletDeletion) await queryRunner.rollbackTransaction() // Rollback on failure throw new Error(`Impossible to delete the customer in DB (step 2) - ${walletDeletion.message}`) } } // Step 3: Delete the customer const UserRepository = queryRunner.manager.getRepository(Customer) const deletedUser = await UserRepository.delete(customerId).catch((err) => err) // Handle customer deletion errors if (deletedUser instanceof Error) { logger.error(deletedUser) await queryRunner.rollbackTransaction() // Rollback on failure throw new Error(`Impossible to delete the customer in DB (step 3) - ${deletedUser.message}`) } if (deletedUser.affected === 0) { logger.error(deletedUser) throw new Error('Impossible to delete the customer in DB (step 3) - no row affected') } // Commit the transaction await queryRunner.commitTransaction() // Release the query runner await queryRunner.release() return true // Return success } // Get a customer's wallet info by their ID export const getCustomerWalletInfoDB = async (customerId: string) => { const connection = await getConnection() // Get DB connection const CustomerRepository = connection.getRepository(Customer) // Get User repository // Query to fetch customer's wallet info const customerWalletInfo = await CustomerRepository.createQueryBuilder('customer') .innerJoinAndMapOne('customer.Wallet', Wallet, 'wallet', 'wallet.customer_id = customer.customer_id') .where('customer.customer_id = :customerId', { customerId: customerId }) .getOne() .catch((err) => err) // Handle query errors if (customerWalletInfo instanceof Error) { logger.error(customerWalletInfo) throw new Error(`Impossible to get the custumer info - ${customerWalletInfo.message}`) } // Handle case where customer doesn't exist if (customerWalletInfo == null) { throw new Error('Impossible to get any customer with that ID (response is null - customer doesnt exist)') } return getAllCustomersDBAdapter(customerWalletInfo) // Return customer's wallet info } ------- file: ./src/v1/infrastructure/persistence/database/wallet/entity.ts ------- import { Column, Entity, Index, JoinColumn, OneToOne, PrimaryColumn } from 'typeorm' import { Customer } from '../customer/entity' @Entity() export class Wallet { @PrimaryColumn('varchar') wallet_id!: string @Column('int') hard_currency!: number @Column('int') soft_currency!: number @Index('idx_wallet_customer_id') @OneToOne(() => Customer, { cascade: true, onDelete: 'CASCADE' }) @JoinColumn({ name: 'customer_id', referencedColumnName: 'customer_id' }) customer!: Customer } ------- file: ./src/v1/infrastructure/persistence/database/wallet/walletDB.dto.ts ------- import { wallet } from '../../../../services/wallet/dto' export type walletDBDTO = {} & wallet ------- file: ./src/v1/infrastructure/persistence/database/wallet/index.ts ------- import { getConnection } from '../db_connection/connectionFile' import { Wallet } from './entity' import { walletDBDTO } from './walletDB.dto' import { v4 as uuidv4 } from 'uuid' import { QueryRunner } from 'typeorm' import { Customer } from '../customer/entity' import { moneyTypes, moneyTypesO2 } from '../../../../domain' import logger from '../../../../helpers/logger' export const getWalletByIdDB = async (walletId: string): Promise<walletDBDTO> => { const connection = await getConnection() const WalletsRepository = connection.getRepository(Wallet) const wallet = await WalletsRepository.findOne({ where: { wallet_id: walletId } }).catch((err) => err) if (wallet instanceof Error) { logger.error(wallet) throw new Error(`Impossible to found the requested wallet - ${wallet.message}`) } return wallet as walletDBDTO } export const updateWalletByWalletIdDB = async (walletId: string, currencyType: moneyTypes, newBalance: number): Promise<boolean> => { const connection = await getConnection() const WalletsRepository = connection.getRepository(Wallet) const result = await WalletsRepository.update(walletId, { [moneyTypesO2[currencyType]]: newBalance }).catch((err) => err) if (result instanceof Error) { logger.error(result) throw new Error(`Impossible to found the requested wallet - ${String(result)}`) } return true } export const updateWalletByWalletIdTransaction = async (transactionRunner: QueryRunner, walletId: string, currencyType: moneyTypes, newBalance: number): Promise<boolean> => { // logger.debug(JSON.stringify([walletId, currencyType, newBalance])) const WalletsRepository = transactionRunner.manager.getRepository(Wallet) const curr = String(moneyTypesO2[currencyType]) const result = await WalletsRepository.update(walletId, { [curr]: newBalance }).catch((err) => err) if (result instanceof Error) { logger.error(result) throw new Error(`Error while updating wallet - ${String(result)}`) } if (result.affected === 0) throw new Error('Impossible to found the requested wallet') return true } export const createNewWalletDB = async (customer: Customer): Promise<walletDBDTO> => { const connection = await getConnection() const WalletsRepository = connection.getRepository(Wallet) const newWalletToSave: Wallet = new Wallet() newWalletToSave.wallet_id = uuidv4() newWalletToSave.customer = customer newWalletToSave.hard_currency = Math.floor(Math.random() * 2000) newWalletToSave.soft_currency = Math.floor(Math.random() * 2000) const newWallet = await WalletsRepository.save(newWalletToSave).catch((err) => err) if (newWallet instanceof Error) { logger.error(newWallet) throw new Error(`Impossible to save the new wallet - ${newWallet.message}`) } return newWallet } export const deleteWalletByIdDB = async (walletId: string): Promise<boolean> => { const connection = await getConnection() const WalletsRepository = connection.getRepository(Wallet) const result = await WalletsRepository.delete({ wallet_id: walletId }).catch((err) => err) if (result instanceof Error || result.affected === 0) { logger.error(result) throw new Error(`Impossible to delete the wallet - ${result.message}`) // Use a custom error message } return true } export const deleteWalletByIdDBTransaction = async (queryRunner: QueryRunner, walletId: string) => { const WalletsRepository = queryRunner.manager.getRepository(Wallet) const result = await WalletsRepository.delete({ wallet_id: walletId }).catch((err) => err) if (result instanceof Error) { logger.error(result) throw new Error(`Impossible to delete the wallet - ${String(result)}`) // Use a custom error message } if (result.affected === 0) { const errStr = `Impossible to delete the wallet - No wallet found - idWallet = ${walletId}` logger.error(errStr) throw new Error(errStr) // Use a custom error message } return true } ------- file: ./src/v1/infrastructure/persistence/database/db_connection/connectionFile.ts ------- import { DataSourceOptions, QueryRunner, DataSource } from 'typeorm' import logger from '../../../../helpers/logger' import { v4 as uuidv4 } from 'uuid' export type transactionQueryRunnerType = QueryRunner // This is the permanent connection to the DB that will be reuse through the whole app cycle let connection: DataSource | null = null /** * Generates connection options for the database based on environment variables. * @returns {Promise<DataSourceOptions>} - The database connection options. */ const getConnectionOptions = async (): Promise<DataSourceOptions> => { return { name: `db_connection_${uuidv4()}`, // Unique connection name type: process.env.DB_DRIVER, // Database type (e.g., mysql) host: process.env.DB_HOST, // Database host url: process.env.DB_URI, // Full database URL port: Number(process.env.DB_PORT), // Database port username: process.env.DB_USERNAME, // Database username password: process.env.DB_PASSWORD, // Database password database: process.env.DB_DATABASE_NAME, // Database name entities: [__dirname + '/../**/entity.*s'], // Path to entity files synchronize: false, // Disable auto-sync poolSize: 10, // Max connections in the pool idleTimeout: 30000, poolErrorHandler: (err) => logger.error('Connection pool error:', err), // Handle pool errors extra: { connectionLimit: 10, // Max connections (matches poolSize) queueLimit: 0 // No limit on queued requests } } as DataSourceOptions } /** * Attempts to connect to the database using the generated connection options. * @returns {Promise<DataSource>} - The initialized database connection. * @throws {Error} - If the connection fails. */ export const tryToConnectDB = async (): Promise<DataSource> => { try { const dbOptions: DataSourceOptions = await getConnectionOptions() // Get connection options const connection: DataSource = new DataSource(dbOptions) // Create new DataSource await connection.initialize() // Initialize the connection return connection } catch (error) { const errorMessage = `Failed to create a new connection to DB - ${String(error)}` logger.error(errorMessage) // Log connection error throw new Error(errorMessage) } } /** * Connects to the database with retry logic for transient failures. * @param {number} currenAttempt - The current retry attempt (default: 1). * @param {number} maxAttempts - The maximum number of retry attempts (default: 4). * @param {number} delay - The initial delay between retries in milliseconds (default: 150). * @returns {Promise<DataSource>} - The initialized database connection. * @throws {Error} - If the connection fails after max attempts. */ export const connectionDB = async (currenAttempt: number = 1, maxAttempts: number = 4, delay: number = 150): Promise<DataSource> => { try { return await tryToConnectDB() // Attempt to connect } catch (error) { if (currenAttempt < maxAttempts) { const nextAttempt = currenAttempt + 1 // Increment attempt count const waitTime = delay * Math.pow(2, currenAttempt) // Exponential backoff logger.warn(`Warning - fail to connect to DB - retry in ${waitTime} seconds`) await new Promise((resolve) => setTimeout(resolve, waitTime)) // Wait before retrying return connectionDB(nextAttempt, maxAttempts, delay) // Retry connection } // Throw error if max attempts reached const errorInfo = `Error - Impossible to connect to db after ${maxAttempts} attempts - ${String(error)}` logger.error(errorInfo) throw new Error(errorInfo) } } /** * Gets or creates a database connection. Reuses an existing connection if available. * @returns {Promise<DataSource>} - The database connection. * @throws {Error} - If the connection fails. */ export const getConnection = async (): Promise<DataSource> => { if (connection && connection.isInitialized) return connection // Return existing connection if available const newConnection = await connectionDB().catch((err) => err) // Attempt to connect if (connection instanceof Error) { const errorMessage = `Failed to establish database connection - ${String(connection)}` logger.error(errorMessage) throw new Error(errorMessage) } return newConnection // Return the new connection } /** * Closes the database connection if it exists and is initialized. * @returns {Promise<void>} * @throws {Error} - If closing the connection fails. */ export const closeConnection = async (): Promise<void> => { if (connection && connection.isInitialized) { try { await connection.destroy() // Destroy the connection connection = null // Clear the connection object } catch (error) { const errorMessage = `Error closing database connection - ${String(error)}` logger.error(errorMessage) throw new Error(errorMessage) } } } /** * Creates and starts a new database transaction. * @returns {Promise<QueryRunner>} - The query runner for the transaction. * @throws {Error} - If the transaction cannot be created. */ export const createAndStartTransaction = async (): Promise<QueryRunner> => { try { const connection = await getConnection() // Get database connection const queryRunner = connection.createQueryRunner() // Create query runner await queryRunner.connect() // Connect the query runner await queryRunner.startTransaction() // Start the transaction return queryRunner } catch (error) { const errorMessage = `Error impossible to create transaction runner object - ${String(error)}` logger.error(errorMessage) throw new Error(errorMessage) } } /** * Commits and releases a transaction. * @param {QueryRunner} queryRunner - The query runner for the transaction. * @returns {Promise<boolean>} - True if the transaction is successfully committed. * @throws {Error} - If committing the transaction fails. */ export const commitAndQuitTransactionRunner = async (queryRunner: QueryRunner): Promise<boolean> => { try { await queryRunner.commitTransaction() // Commit the transaction await queryRunner.release() // Release the query runner return true } catch (error) { const errorMessage = `Error trying to commit transaction to DB - ${String(error)}` logger.error(errorMessage) throw new Error(errorMessage) } } /** * Rolls back and releases a transaction. * @param {QueryRunner} queryRunner - The query runner for the transaction. * @returns {Promise<boolean>} - True if the transaction is successfully rolled back. * @throws {Error} - If rolling back the transaction fails. */ export const rollBackAndQuitTransactionRunner = async (queryRunner: QueryRunner): Promise<boolean> => { try { await queryRunner.rollbackTransaction() // Rollback the transaction await queryRunner.release() // Release the query runner return true } catch (error) { const errorMessage = `Error trying to rollback transaction - ${String(error)}` logger.error(errorMessage) throw new Error(errorMessage) } } /** * Acquires a lock on a wallet for transaction safety. * @param {QueryRunner} queryRunner - The query runner for the transaction. * @param {string} walletId - The ID of the wallet to lock. * @returns {Promise<boolean>} - True if the lock is successfully acquired. * @throws {Error} - If acquiring the lock fails. */ export const acquireLockOnWallet = async (queryRunner: QueryRunner, walletId: string): Promise<boolean> => { const lockResult = await queryRunner.query('SELECT * FROM wallet WHERE wallet_id = ? FOR UPDATE', [walletId]).catch((err) => err) if (lockResult instanceof Error) { const errorInfo = `Error - Impossible to set the lock for db transaction - ${String(lockResult)}` logger.error(errorInfo) throw new Error(errorInfo) } return lockResult.length > 0 // Return true if lock is acquired } ------- file: ./src/v1/infrastructure/persistence/database/db_scripts/80_sqlCreation.sql ------- CREATE USER IF NOT EXISTS '${MYSQL_USER}'@'%' IDENTIFIED BY '${MYSQL_PASSWORD}'; GRANT ALL PRIVILEGES ON `${MYSQL_DATABASE}`.* TO '${MYSQL_USER}'@'%'; FLUSH PRIVILEGES; drop table if exists wallet; drop table if exists customer; create table customer( customer_id varchar(50) primary key, firstname varchar(50), lastname varchar(50) ); insert into customer(customer_id, firstname, lastname) values ("22ef5564-0234-11ed-b939-0242ac120002", "Carol", "Peletier"), ("35269564-0234-11ed-b939-0242ac120002", "Beth", "Greene"), ("14523564-0234-11ed-b939-0242ac120002", "Glen", "Rhee"), ("68965564-0234-11ed-b939-0242ac120002", "Rick", "Grimes"); create table wallet( wallet_id varchar(50) primary key, customer_id varchar(50), hard_currency int, soft_currency int, INDEX idx_wallet_customer_id (customer_id), FOREIGN KEY (customer_id) REFERENCES customer(customer_id) ); insert into wallet(wallet_id, customer_id, hard_currency, soft_currency) values ("515f73c2-027d-11ed-b939-0242ac120002", "22ef5564-0234-11ed-b939-0242ac120002", 1000, 1240), ("698f73c2-027d-11ed-b939-0242ac120002", "35269564-0234-11ed-b939-0242ac120002", 250, 450), ("412cddd2-027d-11ed-b939-0242ac120002", "14523564-0234-11ed-b939-0242ac120002", 850, 750), ("96373dc2-027d-11ed-b939-0242ac120002", "68965564-0234-11ed-b939-0242ac120002", 950, 650); ------- file: ./src/v1/infrastructure/persistence/database/db_scripts/40_permission.sh ------- chmod -R 777 /var/lib/mysql ------- file: ./src/v1/presentation/routes/user/error.dto.ts ------- import { errorType } from '../../../domain/error' export const errorAPIUSER = { errorAPIGetAllUsers: { name: 'errorAPIGetAllUsers', message: 'Error - Impossible to get any user from database' }, errorAPIUserCreation: { name: 'errorAPIUserCreation', message: 'Error - Impossible to save the new user' }, errorAPIGetUser: { name: 'errorAPIGetUser', message: 'Error - Impossible to found the requested user from database' }, errorAPIInvalidUserId: { name: 'errorAPIInvalidUserId', message: 'Error - The userId provided is wrong' }, errorAPIDeleteUser: { name: 'errorAPIDeleteUser', message: 'Error - Impossible to delete the user from database' }, errorAPIUserTransfertWrongParams: { name: 'errorAPIUserTransfertWrongParams', message: 'Error - The params provided are wrong' }, errorAPIUserTransferIllegalAmount: { name: 'errorAPIUserTransferIllegalAmount', message: 'Error - The amount for transferingmust be > 0 ' }, errorAPIUserTransferNoResults: { name: 'errorAPIUserTransferNoResults', message: 'Error - The query returned no results' }, errorAPIUserTransferSelf: { name: 'errorAPIUserTransferSelf', message: 'Error - Same id for receiver and sender' } } as const export const errorValidationUser: Record<string, errorType> = { errorParamUserId: { name: 'errorValidationUser', message: 'Error - Wrong userId info in route - middleware error' } } as const ------- file: ./src/v1/presentation/routes/user/apiResponse.dto.ts ------- import { userWalletDTO } from '../../../services/user/dto' export type apiResponseGetAllUserType = { data: userWalletDTO[] } export type apiResponseGetUserType = { data: userWalletDTO } export type apiResponseDeleteUserType = { data: boolean } export type apiResponseCreateUserType = apiResponseGetUserType ------- file: ./src/v1/presentation/routes/user/index.ts ------- import '../../../../bin/tracing' import { Router, Request, Response } from 'express' import { deleteUserById, getAllUsers, getAllUsersStream, getUserWalletInfo, saveNewUser, transferMoney } from '../../../services/user/index' import { errorAPIUSER } from './error.dto' import logger from '../../../helpers/logger' import { apiResponseGetAllUserType, apiResponseGetUserType, apiResponseCreateUserType, apiResponseDeleteUserType } from './apiResponse.dto' import { userWalletDTO } from '../../../services/user/dto' import { validateUserId } from '../../middlewares/user/user.validation' import { trace, Span, Tracer, SpanOptions } from '@opentelemetry/api' const userRouter = Router() userRouter .route('/') .get(async (_: Request, res: Response) => { const tracer: Tracer = trace.getTracer('user-service') const spanOptions: SpanOptions = { startTime: Date.now() } return tracer.startActiveSpan('getAllUsers', spanOptions, async (span: Span) => { // Add attributes (tags) to the span span.setAttribute('http.route', '/users') const { traceId } = span.spanContext() logger.info(traceId) try { const results = await getAllUsers().catch((err) => err) if (results instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIGetAllUsers.message} \n ${String(results)}` logger.error(errInfo) return res.status(588).end(errInfo) } const apiRes: apiResponseGetAllUserType = { data: results as userWalletDTO[] } span.end() return res.status(200).json(apiRes) } catch (err) { if (err instanceof Error) span.recordException(String(err)) span.end() const errInfo: string = `route:getAllUsers - Internal Server Error - ${err}` return res.status(500).send(errInfo) } }) }) .post(async (req: Request, res: Response) => { const { firstname, lastname } = req.body const result = await saveNewUser(firstname, lastname).catch((err) => { logger.error(err) return err }) if (result instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIUserCreation?.message} \n ${result.message}` return res.status(500).send(errInfo) } const response: apiResponseCreateUserType = { data: result } return res.status(200).json(response) }) // New route for transferring money userRouter.route('/transfer').post(async (req: Request, res: Response) => { const { senderId, receiverId, amount, currency } = req.body // Validate required fields if (!senderId || !receiverId || !amount || !currency) { return res.status(400).json(errorAPIUSER.errorAPIUserTransfertWrongParams) } // Validate amount is a positive number if (typeof amount !== 'number' || amount <= 0) { return res.status(498).json(errorAPIUSER.errorAPIUserTransferIllegalAmount) } if (senderId === receiverId) { return res.status(404).json(errorAPIUSER.errorAPIUserTransferSelf) } // Call the transferMoney service const result = await transferMoney(currency, senderId, receiverId, amount).catch((err) => { logger.error(err) return err }) if (result instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIUserTransferNoResults?.message} \n ${result.message}` return res.status(500).send(errInfo) } const response = { data: result } return res.status(200).json(response) }) userRouter.route('/stream').get(async (_: Request, res: Response) => { const usersStream = await getAllUsersStream().catch((err) => err) if (usersStream instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIGetAllUsers?.message} \n ${usersStream.message}` return res.status(500).send(errInfo) } // usersStream.on('data', (d: any) => logger.debug(d)) return usersStream.pipe(res) }) userRouter .route('/:userId') .get(validateUserId, async (req: Request, res: Response) => { const result = await getUserWalletInfo(String(req.params.userId)).catch((err) => err) if (result instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIGetUser.message} \n ${result.message}` return res.status(500).send(errInfo) } return res.status(200).json({ data: result } as apiResponseGetUserType) }) .delete(validateUserId, async (req: Request, res: Response) => { const result = await deleteUserById(String(req.params.userId)).catch((err) => err) if (result instanceof Error) { const errInfo = `presentationError: ${errorAPIUSER.errorAPIDeleteUser?.message} \n ${result.message}` return res.status(500).send(errInfo) } return res.status(200).json({ data: result } as apiResponseDeleteUserType) }) export default userRouter ------- file: ./src/v1/presentation/middlewares/user/user.validation.ts ------- import { z } from 'zod' import { Request, Response, NextFunction } from 'express' export const validateUserId = async (req: Request, res: Response, next: NextFunction) => { const { userId } = req.params const UserIdScheme = z.string().length(36) try { UserIdScheme.parse(userId) next() return } catch (err) { return res.status(404).json({ middlewareError: `This userId ${userId} is not valid`, validationError: String(err) }) } } ------- file: ./src/v1/presentation/middlewares/.gitkeep ------- ------- file: ./src/v1/domain/index.ts ------- export const moneyTypesO = { hard_currency: 'hardCurrency', soft_currency: 'softCurrency' } as const export const moneyTypesO2 = { hardCurrency: 'hard_currency', softCurrency: 'soft_currency' } as const export type moneyTypes = (typeof moneyTypesO)[keyof typeof moneyTypesO] ------- file: ./src/v1/domain/error.ts ------- export type errorType = { name: string message: string } ------- file: ./src/v1/helpers/apiDocumentation/v2/index.ts ------- import ip from 'ip' const localIp = ip.address() const apiDocumentation = { swagger: '2.0', host: `${localIp}:${process.env.API_PORT || 8080}`, basePath: '/api/v1', info: { title: 'rest_api_backend_user', version: '1' }, schemes: ['http'], // use for model definition definitions: { User: { type: 'object', properties: { userId: { description: 'id of user', type: 'string' }, walletId: { description: 'Each user have a wallet', type: 'string' }, firstname: { description: 'firstname of the user', type: 'string' }, lastname: { description: 'The user lastname', type: 'string' } }, required: ['userId'] } }, paths: { '/user': { get: { tags: ['user'], summary: 'get all users', description: 'all users will be retrieve from DB', responses: { '200': { description: 'Successfuly get all users ' } } }, post: { tags: ['user'], summary: 'Save a new user in database', description: 'Save a new user in database', parameters: [ { in: 'body', name: 'body', description: 'The user first and last name', required: true, schema: { type: 'object', properties: { firstname: { description: 'User’s first name', type: 'string' }, lastname: { description: 'User’s last name', type: 'string' } }, required: ['firstname', 'lastname'] } } ], responses: { '200': { description: 'Successfully save new user' } } } }, '/user/stream': { get: { tags: ['user'], summary: 'get all users from stream', description: 'all users will be retrieve from DB', responses: { '200': { description: 'Successfuly get all users with a stream ' } } } }, '/user/{userId}': { get: { tags: ['user'], summary: 'Get a single user', description: 'Get a user from DB by its id', parameters: [ { name: 'userId', in: 'path', required: true, type: 'string', description: 'Id of a user (user_id)' } ], responses: { '200': { description: 'Successfully get the requestesd user' } } }, delete: { tags: ['user'], summary: 'delete a user by id', description: 'Delete a user by id', parameters: [ { name: 'userId', in: 'path', required: true, type: 'string', description: 'Id of a user (user_id)' } ], responses: { '200': { description: 'Successfully delete the requested user' } } } }, '/user/transfer': { post: { tags: ['user'], summary: 'Transfer money between wallets', description: 'Transfer a specified amount of money from one wallet to another', parameters: [ { in: 'body', name: 'body', description: 'Transfer details', required: true, schema: { type: 'object', required: ['senderId', 'receiverId', 'amount', 'currency'], properties: { senderId: { type: 'string', description: 'ID of the sender' }, receiverId: { type: 'string', description: 'ID of the receiver' }, amount: { type: 'number', description: 'Amount to transfer (must be positive)', minimum: 0, exclusiveMinimum: true }, currency: { type: 'string', description: 'Currency of the transfer' } } } } ], responses: { '200': { description: 'Successfully transferred money', schema: { type: 'object', properties: { data: { type: 'object', description: 'Transfer result details' } } } }, '400': { description: 'Bad request - Missing required fields or invalid amount', schema: { type: 'object', properties: { message: { type: 'string', example: 'Missing required fields' } } } }, '500': { description: 'Internal server error', schema: { type: 'object', properties: { message: { type: 'string', example: 'Failed to transfer money' } } } } } } } } } export default apiDocumentation ------- file: ./src/v1/helpers/apiDocumentation/v3/index.ts ------- import { OpenAPIObject } from 'openapi3-ts/oas31' const API_VERSION = process.env.API_VERSION || '1.0.0' const API_BASEPATH = process.env.API_BASEPATH || '/api/v1' const API_PORT = process.env.API_PORT || 8080 const apiDocumentation: OpenAPIObject = { openapi: '3.1.0', info: { title: 'REST API nodejs typescript', description: 'REST API for user management and wallet transactions', version: API_VERSION, contact: { name: 'API Support', email: 'support@walletapi.com' }, license: { name: 'MIT', url: 'https://opensource.org/licenses/MIT' } }, servers: [ { url: `http://localhost:${API_PORT}${API_BASEPATH}`, description: 'Local development server' } ], components: { schemas: { User: { type: 'object', required: ['userId', 'firstname', 'lastname'], properties: { userId: { type: 'string', format: 'uuid', example: '550e8400-e29b-41d4-a716-446655440000', description: 'Unique identifier for the user' }, firstname: { type: 'string', minLength: 2, example: 'John', description: 'The user first name' }, lastname: { type: 'string', minLength: 2, example: 'Doe', description: 'The user s last name' }, walletId: { type: 'string', format: 'uuid', example: '550e8400-e29b-41d4-a716-446655440001', description: 'Associated wallet ID' } } }, ErrorResponse: { type: 'object', properties: { error: { type: 'string', example: 'Invalid request parameters' }, details: { type: 'array', items: { type: 'string' }, example: ['amount must be positive number'] }, code: { type: 'string', example: 'VALIDATION_ERROR' } } } } }, paths: { '/user': { get: { tags: ['user'], summary: 'Get all users', description: 'Retrieves a list of all registered users with their wallet information', security: [{ BearerAuth: [] }], responses: { '200': { description: 'Successful operation', content: { 'application/json': { schema: { type: 'array', items: { $ref: '#/components/schemas/User' } } } } }, '401': { description: 'Unauthorized', content: { 'application/json': { schema: { $ref: '#/components/schemas/ErrorResponse' } } } } } }, post: { tags: ['user'], summary: 'Create new user', description: 'Registers a new user with initial wallet setup', requestBody: { required: true, content: { 'application/json': { schema: { type: 'object', required: ['firstname', 'lastname'], properties: { firstname: { $ref: '#/components/schemas/User/properties/firstname' }, lastname: { $ref: '#/components/schemas/User/properties/lastname' } } } } } }, responses: { '201': { description: 'User created successfully', content: { 'application/json': { schema: { $ref: '#/components/schemas/User' } } } } } } }, '/user/stream': { get: { tags: ['user'], summary: 'Stream users', description: 'Real-time stream of user data updates', security: [{ BearerAuth: [] }], responses: { '200': { description: 'Successful operation', content: { 'text/event-stream': { schema: { type: 'string', format: 'binary' } } } } } } }, '/user/{userId}': { get: { tags: ['user'], summary: 'Get user by ID', description: 'Retrieves detailed information about a specific user', parameters: [ { name: 'userId', in: 'path', required: true, schema: { $ref: '#/components/schemas/User/properties/userId' } } ], responses: { '200': { description: 'Successful operation', content: { 'application/json': { schema: { $ref: '#/components/schemas/User' } } } } } }, delete: { tags: ['user'], summary: 'Delete user', description: 'Permanently removes a user and associated wallet', parameters: [ { name: 'userId', in: 'path', required: true, schema: { $ref: '#/components/schemas/User/properties/userId' } } ], responses: { '204': { description: 'User deleted successfully' } } } }, '/user/transfer': { post: { tags: ['user'], summary: 'Create transaction', description: 'Transfer funds between wallets', security: [{ BearerAuth: [] }], requestBody: { required: true, content: { 'application/json': { schema: { type: 'object', required: ['senderId', 'receiverId', 'amount', 'currency'], properties: { senderId: { type: 'string', description: 'ID of the sender' }, receiverId: { type: 'string', description: 'ID of the receiver' }, amount: { type: 'number', description: 'Amount to transfer (must be positive)', minimum: 0, exclusiveMinimum: 0 }, currency: { type: 'string', description: 'Currency of the transfer' } } } } } }, responses: { '202': { description: 'Transaction accepted for processing', content: { 'application/json': { schema: { type: 'object', properties: { transactionId: { type: 'string', format: 'uuid' }, status: { type: 'string', enum: ['PENDING', 'COMPLETED', 'FAILED'] } } } } } }, '422': { description: 'Business rule violation', content: { 'application/json': { schema: { $ref: '#/components/schemas/ErrorResponse' } } } } } } } } } export default apiDocumentation ------- file: ./src/v1/helpers/apiDocumentation/v3/docOptions.ts ------- import { SwaggerUiOptions } from 'swagger-ui-express' export const openApiOptions: SwaggerUiOptions = { customSiteTitle: 'API Backend Template - OpenAPI 3.0 (Dark Theme)', customCss: ` .swagger-ui, .swagger-ui .wrapper { background-color: #f5f5f5; color: #212121; } .swagger-ui .topbar { background-color: #3f51b5; color: #ffffff; } .swagger-ui .topbar a { color: #ffffff; } .swagger-ui .scheme-container { background-color: #ffffff; box-shadow: 0 2px 4px rgba(0,0,0,0.1); } .swagger-ui .opblock-tag { color: #ffffff; background-color: #3f51b5; } .swagger-ui .opblock { background-color: #ffffff; border: 1px solid #e0e0e0; border-radius: 4px; } .swagger-ui .opblock .opblock-summary { background-color: #fafafa; } .swagger-ui .opblock .opblock-summary-method { color: #3f51b5; font-weight: bold; } .swagger-ui .opblock .opblock-summary-path { color: #616161; } .swagger-ui .opblock-body pre { background-color: #eceff1; color: #212121; } .swagger-ui .btn { background-color: #3f51b5; color: #ffffff; border-radius: 4px; } .swagger-ui .btn:hover { background-color: #5c6bc0; } .swagger-ui input[type="text"], .swagger-ui textarea { background-color: #ffffff; color: #212121; border: 1px solid #e0e0e0; border-radius: 4px; } `, customfavIcon: '/favicon.ico', // Optional: ensure this exists in public/ swaggerOptions: { defaultModelsExpandDepth: 2, displayOperationId: true, docExpansion: 'list', filter: true, tryItOutEnabled: true, displayRequestDuration: true }, explorer: true } ------- file: ./src/v1/helpers/logger/index.ts ------- import winston, { transports } from 'winston' import { OpenTelemetryTransportV3 } from '@opentelemetry/winston-transport' const logger = winston.createLogger({ format: winston.format.combine( winston.format.errors({ stack: true }), // Important for error handling winston.format.timestamp(), winston.format.printf(({ level, message, timestamp, stack }) => { let logMessage = `${timestamp} ${level}: ${message}` if (typeof stack === 'string') { const stackLines = stack.split('\n') // The second line of the stack trace typically contains the file and line number const errorLocation = stackLines[1]?.trim() || 'Unknown location' logMessage += `\n[${errorLocation}]` } else if (stack) { // Handle cases where stack exists but is not a string (e.g., custom error objects) logMessage += '\n[Stack trace unavailable]' } return logMessage }) ), exceptionHandlers: [new transports.File({ filename: './logs/exceptions.log' })] }) logger.add(new OpenTelemetryTransportV3({})) logger.add(new transports.Console()) if (process.env.NODE_ENV === 'production') { logger.level = 'error' logger.add( new transports.File({ level: 'error', filename: './logs/error.log', handleRejections: true }) ) } else { logger.level = process.env.LOGLEVEL || 'debug' } export default logger ------- file: ./src/v1/helpers/crypto/index.ts ------- import crypto from 'crypto-js' const secretKey: string = process.env.CRYPTO_SECRET_KEY || '' if (!secretKey) throw new Error('Please specify a secretKey for encryption') export const encryptData = async (str: string): Promise<string> => { const cipher = crypto.AES.encrypt(str, secretKey) const encryptedStr: string = cipher.toString() return encryptedStr } export const decryptData = async (encryptedData: string): Promise<string> => { const bytes = crypto.AES.decrypt(encryptedData, secretKey) const decryptedStr: string = bytes.toString(crypto.enc.Utf8) return decryptedStr } ------- file: ./src/bin/server.ts ------- require('dotenv').config() import * as http from 'http' import ip from 'ip' import app from '../app' import logger from '../v1/helpers/logger' import { closeConnection } from '../v1/infrastructure/persistence/database/db_connection/connectionFile' const urlBase: string = 'api/v1' const localIp: string = ip.address() const port: number = Number(process.env.API_PORT) || 8080 const server: http.Server = http.createServer(app) // Graceful shutdown const shutdown = async () => { try { await closeConnection() process.exit(0) } catch (error) { logger.error('Error during shutdown:', error) process.exit(1) } } server.on('error', async (error) => { logger.error(JSON.stringify(error)) await shutdown() process.exit(1) }) server.on('listening', async () => { if (!process.env.production) logger.info(`app running ... api documentation on localhost:${port} or http://${localIp}:${port}/${urlBase}/doc3/apiDocumentation`) }) // Setup process handlers process.on('SIGTERM', shutdown) process.on('SIGINT', shutdown) server.listen(port) ------- file: ./src/bin/tracing.ts ------- import { NodeSDK } from '@opentelemetry/sdk-node' // import { ConsoleSpanExporter } from '@opentelemetry/sdk-trace-node' import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics' import { SimpleLogRecordProcessor } from '@opentelemetry/sdk-logs' import { resourceFromAttributes } from '@opentelemetry/resources' import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions' import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc' import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc' import { OTLPLogExporter } from '@opentelemetry/exporter-logs-otlp-grpc' import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node' // import { OTLPLogExporter } from '@opentelemetry/exporter-logs-otlp-http' // Use HTTP exporter for logs // import { BatchLogRecordProcessor } from '@opentelemetry/sdk-logs' import logger from '../v1/helpers/logger' export const sdk = new NodeSDK({ resource: resourceFromAttributes({ [ATTR_SERVICE_NAME]: process.env.API_NAME || 'api-node-typescript', [ATTR_SERVICE_VERSION]: process.env.API_VERSION || '1.0' }), instrumentations: [getNodeAutoInstrumentations()], metricReader: new PeriodicExportingMetricReader({ // exporter: new ConsoleMetricExporter() exporter: new OTLPMetricExporter({ url: 'http://otel-collector:4317/v1/metrics' }) }), traceExporter: new OTLPTraceExporter({ url: 'http://otel-collector:4317/v1/traces' }), // traceExporter: new ConsoleSpanExporter(), // logRecordProcessor: new BatchLogRecordProcessor( // new OTLPLogExporter({ // url: process.env.OTEL_LOGS_EXPORTER_ENDPOINT || 'http://otel-collector:34317/v1/logs' // Use HTTP port for logs // // You can add headers here if needed // // headers: {}, // }) // ) logRecordProcessors: [new SimpleLogRecordProcessor(new OTLPLogExporter({ url: 'http://otel-collector:4317/v1/logs' }))] }) try { sdk.start() logger.info('✅ OpenTelemetry started') logger.info(`urlTrace: ${process.env.OTEL_EXPORTER_OTLP_ENDPOINT}, url: ${process.env.OTEL_EXPORTER_OTLP_ENDPOINT}`) } catch (error) { logger.error('❌ Error starting OpenTelemetry', error) } export default sdk ------- file: ./ecosystem.config.js ------- module.exports = { apps: [ { name: 'tracing', script: './dist/bin/tracing.js', exec_mode: 'cluster', instances: 1 }, { name: 'server', script: './dist/bin/server.js', exec_mode: 'cluster', instances: 1, wait_ready: true, listen_timeout: 500 } ] } ------- file: ./.github/workflows/ci.yml ------- name: CI/CD Pipeline on: push: branches: - main pull_request: branches: - main env: NODE_VERSION: 22 DOCKER_IMAGE: gary003/rest_api_nodejs_typescript DOCKER_TAG: latest jobs: # security-scan: # runs-on: ubuntu-latest # steps: # - name: Checkout code # uses: actions/checkout@v4 # - name: Setup Node.js # uses: actions/setup-node@v4 # with: # node-version: ${{ env.NODE_VERSION }} # - name: Install dependencies # run: npm ci # # Static Analysis - Trivy # - name: Trivy filesystem scan # uses: aquasecurity/trivy-action@master # with: # scan-type: 'fs' # scan-ref: '.' # format: 'sarif' # output: 'trivy-results.sarif' # # # Dependency Scanning - Snyk # # - name: Snyk dependency scan # # uses: snyk/actions/node@master # # env: # # SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }} # # with: # # args: --severity-threshold=medium --sarif-file-output=snyk.sarif # # Build Docker image # - name: Build Docker image # run: npm run docker:build:image # # Container Scanning - Trivy # - name: Trivy container scan # uses: aquasecurity/trivy-action@master # with: # image-ref: '' # format: 'sarif' # output: 'trivy-container.sarif' # # Start application for DAST # - name: Start application # run: | # docker run -d -p 3000:3000 --name test-app ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} # sleep 30 # # Dynamic Analysis - OWASP ZAP # - name: OWASP ZAP scan # uses: zaproxy/action-baseline@v0.10.0 # with: # target: 'http://localhost:3000' # rules_file_name: '.zap/rules.tsv' # # Upload all results to GitHub Security # - name: Upload Trivy results # uses: github/codeql-action/upload-sarif@v2 # with: # sarif_file: 'trivy-results.sarif' # # - name: Upload Snyk results # # uses: github/codeql-action/upload-sarif@v2 # # with: # # sarif_file: 'snyk.sarif' # # Fail build on high severity vulnerabilities # - name: Check for high severity issues # run: | # if grep -q "HIGH\|CRITICAL" trivy-results.sarif; then # echo "High/Critical vulnerabilities found!" # exit 1 # fi test-app: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v4 - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: ${{ env.NODE_VERSION }} cache: 'npm' - name: Install dependencies run: npm ci - name: Create .env file run: | echo "DB_DRIVER=mysql" >> .env echo "DB_HOST=localhost" >> .env # Matches the service name 'mysql' echo "DB_PORT=3306" >> .env echo "DB_USERNAME=root" >> .env echo "DB_PASSWORD=testpassword" >> .env # Matches MYSQL_ROOT_PASSWORD echo "DB_DATABASE_NAME=testdb" >> .env # Matches MYSQL_DATABASE echo "DB_URI=mysql://root:testpassword@localhost:3306/testdb" >> .env echo "API_PORT=8080" >> .env echo "LOGLEVEL=debug" >> .env echo "NODE_ENV=test" >> .env echo "SWAGGER_HOST=localhost:8080" >> .env echo "SWAGGER_BASE_PATH=/api/v1" >> .env - name: Run all tests run: npm run test env: CI: true - name: Upload test artifacts (if failed) if: failure() uses: actions/upload-artifact@v4 with: name: test-logs path: | *.log coverage/ docker-build-image: runs-on: ubuntu-latest needs: test-app steps: - name: Checkout repository uses: actions/checkout@v4 - name: Set up Node.js uses: actions/setup-node@v4 with: node-version: ${{ env.NODE_VERSION }} cache: 'npm' - name: Install dependencies run: npm ci - name: Set up Docker Buildx uses: docker/setup-buildx-action@v3 - name: Build Docker image run: npm run docker:build:image - name: Test Docker image run: | docker run --rm -d -p 8080:8080 --name test-container ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} sleep 5 # Wait for container to start curl --fail http://localhost:8080 || exit 1 docker stop test-container deploy-dockerHub: runs-on: ubuntu-latest needs: docker-build-image steps: - name: Checkout repository uses: actions/checkout@v4 - name: Set up Docker Buildx uses: docker/setup-buildx-action@v3 - name: Log in to Docker Hub uses: docker/login-action@v3 with: username: ${{ secrets.DOCKER_HUB_USERNAME }} password: ${{ secrets.DOCKER_HUB_TOKEN }} logout: true - name: Build and push Docker image uses: docker/build-push-action@v6 with: context: . push: true tags: ${{ env.DOCKER_IMAGE }}:${{ env.DOCKER_TAG }} cache-from: type=gha cache-to: type=gha,mode=max ------- file: ./Dockerfile ------- FROM node:22-alpine WORKDIR /app COPY package*.json ./ RUN ["npm", "install" ] COPY . . EXPOSE 8080 RUN [ "npm", "run", "build:app" ] CMD [ "npm", "run", "docker:launch:app" ] ------- file: ./.prettierrc ------- { "semi": false, "singleQuote": true, "trailingComma": "none", "printWidth": 180, "tabWidth": 2, "useTabs": false, "jsxSingleQuote": true, "arrowParens": "always", "endOfLine": "auto" } ------- file: ./.gitignore ------- # Logs logs *.log npm-debug.log* yarn-debug.log* yarn-error.log* lerna-debug.log* # Diagnostic reports (https://nodejs.org/api/report.html) report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json # Runtime data pids *.pid *.seed *.pid.lock # clinic supervision load test .clinic # Observability volumes trace_data_volume grafana_data_volume # Persistence volumes db_volume # Directory for instrumented libs generated by jscoverage/JSCover lib-cov # Coverage directory used by tools like istanbul coverage *.lcov # nyc test coverage .nyc_output # Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files) .grunt # Bower dependency directory (https://bower.io/) bower_components # node-waf configuration .lock-wscript # Compiled binary addons (https://nodejs.org/api/addons.html) build/Release # Dependency directories node_modules/ jspm_packages/ # TypeScript v1 declaration files typings/ # TypeScript cache *.tsbuildinfo # Optional npm cache directory .npm # Optional eslint cache .eslintcache # Microbundle cache .rpt2_cache/ .rts2_cache_cjs/ .rts2_cache_es/ .rts2_cache_umd/ # Optional REPL history .node_repl_history # Output of 'npm pack' *.tgz # Yarn Integrity file .yarn-integrity # dotenv environment variables file .env .env.test # parcel-bundler cache (https://parceljs.org/) .cache # Next.js build output .next # Nuxt.js build / generate output .nuxt dist # Gatsby files .cache/ # Comment in the public line in if your project uses Gatsby and *not* Next.js # https://nextjs.org/blog/next-9-1#public-directory-support # public # vuepress build output .vuepress/dist # Serverless directories .serverless/ # FuseBox cache .fusebox/ # DynamoDB Local files .dynamodb/ # TernJS port file .tern-port